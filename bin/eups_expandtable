#!/usr/bin/env perl
# -*- perl -*-
#
# Expands the table file by filling in 
# the currently set-up versions.
# Small modifications of install_ups_table in sdsstools.
# Nikhil Padmanabhan, Princeton, 2003
#
# #############################################

$inplace = 0;			# modify table file in place
$warn_versions = 0;		# warn about suspicious versions

while($ARGV[0] =~ /^-/) {
   if($ARGV[0] eq "-h" || $ARGV[0] eq "--help") {
      warn <<EOT;
Usage: eups_expandtable [options] [file.table [directory]]
Options are
    -h, --help    Print this message
    -i, --inplace Modify file in situ
    -p, --product PRODUCT=VERSION   Expand PRODUCT to use VERSION
    -w, --warn    Warn about versions that do not start with v or V

Modify a ups table file, replacing setupRequired and setupOptional
lines which refer to the current version by the actual version number 
of the currently setup product; e.g.
      setupRequired("-f \${EUPS_FLAVOR} astroda")
becomes
      setupRequired("-f \${EUPS_FLAVOR} astroda v13_1")

You can override the version with e.g. -p astroda=rhl; more
than one -p command is permitted.

If a directory is specified, the modified table file will be written
there, with the same name as the original; otherwise it is written to
standard out unless you specify --inplace, in which case the
substitution will be done in situ.  You may omit file.table, or
specify it as \"-\", to read standard input; this implies --inplace.
    
For example, the make target in a ups directory might contain the line:
      eups_expandtable -w iop.table \$(IOP_DIR)/ups
EOT
    exit 1;
   } elsif($ARGV[0] eq "-") {
      last;
   } elsif($ARGV[0] eq "-i" || $ARGV[0] eq "--inplace") {
      $inplace = 1;
   } elsif($ARGV[0] eq "-p" || $ARGV[0] eq "--product") {
      if (!defined($ARGV[1])) {
	 die "Please provide an argument with $ARGV[0]\n";
      }
      my($p, $v) = split(/=/, $ARGV[1]);
      $p =~ tr/a-z/A-Z/;
      $productVersion{$p} = $v;
      shift @ARGV;
   } elsif($ARGV[0] eq "-w" || $ARGV[0] eq "--warn") {
      $warn_versions = 1;
   } else {
      warn "Unknown option: $ARGV[0]\n";
      break;
   }
   shift @ARGV;
}

$filename = $ARGV[0]; shift @ARGV;

if($filename eq "" || $filename eq "-") {
   $IFD = stdin;
   $inplace = 0;
} else {
   open(IFD, "$filename") || die "Cannot open $filename for read\n";
   $IFD = IFD;
}

$dir = $ARGV[0]; shift @ARGV;
if($dir ne "" || $inplace) {
   if ($dir ne "") {
      if ($infile) {
	 warn "I cannot write to a file and inplace simultaneously; ignoring --inplace\n";
      }
      $filename =~ m|([^/]*)$|;
      $outfile = "$dir/$1";
      if($outfile eq $filename) {
	 die "I refuse to overwrite your table file\n";      
      }
   } else {
      rename($filename, "$filename.bak");
      $outfile = $filename;
   }
   open(FD, ">$outfile") || die "I cannot open $outfile\n";
   select(FD);
}

while(<$IFD>) {
   if (/^\s*\#/) {
      print;
      next;
   }
   if ((/(.*setupRequired\("?)([^"]*)("?\).*)/)||(/(.*setupOptional\("?)([^"]*)("?\).*)/)) { # matched the unmatched "
      $head = $1; $body = $2; $tail = $3;

      $flags = $words = "";
      @args = split(" ", $body);
      for($i = 0; $i < @args; $i++) {
	 $a = @args[$i];
	 if($a =~ /^-[fgHmMqrUz]/) {
	    $flags .= "$a $args[$i + 1] ";
	    $i++;
	 } elsif($a =~ /^-[cdejknoPsvtV0-3]/) {
	    $flags .= "$a ";
	 } elsif ($a =~ /^-[BO]/) {
	    &unchanged("I don't know how to process $a"); next;
	 } elsif ($a =~ /^-/) {
	    &unchanged("Unknown flag $a"); next;
	 } else {
	    $words .= "$a ";
	 }
      }
      chop $flags; chop $words;
      $product = $version = "";
      ($product, $version) = split(" ", $words, 2);
      if($product eq "") {
	 &unchanged("I cannot find a product"); next;
      }

      my($logical) = "";
      if ($version =~ /[<=>|]/) { # a logical expression.  We should really check that the setup version is valid
	 $logical = $version;
	 $version = ""
      }

      if($version eq "") {
	 ($uproduct = $product) =~ tr/a-z/A-Z/;
	 if (defined($productVersion{$uproduct})) {
	    $version = $productVersion{$uproduct};
	 }
	 if($version eq "") {
	    if ($ENV{"SETUP_$uproduct"} eq "") {
	       &unchanged("Product $product doesn't appear to be set up");
	       next;
	    }
	    ($prod, $version) = split(" ", $ENV{"SETUP_$uproduct"});
	    if ($version =~ /^-/) {
	       $version = "";
	    }
	    if($prod ne $product) {
	       &unchanged("Invalid setup for $product: $ENV{'SETUP_$uproduct'}");
	       next;
	    }
	 }
	 if($version eq "") {
	    &unchanged("I cannot find a version for $product in:\n\t$ENV{'SETUP_' . $uproduct}\n");
	    next;
	 }
# Check to see if the version is LOCAL --- internal keyword
	 if ($version eq "LOCAL") {
	     &unchanged("I cannot find a version for $product in:\n\t$ENV{'SETUP_' . $uproduct}\n");
	     next;
         }
         if($warn_versions && !($version =~ /^[vV]/)) {
            if(!$warned_about_product{$product}) {
	       $warned_about_product{$product}++;
               printf STDERR "%-30s suspicious version %s\n",
					     "$filename   $product:", $version;
            }
         }
      }

      if($flags ne "") { $flags .= " "; }
      if (!$version && $logical) {
	 $version = $logical;
      }
      print "$head$flags$product $version$tail\n";
   } else {
      print;
   }
}

if ($inplace) {
   unlink("$filename.bak");
}

#
# Print a message and pass a line to the output file unmodified
#
sub unchanged
{
   local($msg) = @_;
   local($line) = $_;
   $line =~ s/^\s*//;
   if ($msg !~ /\n$/) {
      $msg .= " ";
   }
   warn "${msg}in line: $line";
   warn "copying to output unchanged\n"; print;
}
