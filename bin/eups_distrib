#!/usr/bin/env python
# -*- python -*-
#
# Export a product and its dependencies as a package, or install a
# product from a package
#
import atexit
import os, stat
import re, sys
import tempfile
import shutil
import urllib, urllib2
import eups

author = "Robert Lupton (rhl@astro.princeton.edu)"
eups_distrib_version = "1.0"

import warnings
warnings.filterwarnings('ignore', "tmpnam ", RuntimeWarning, "", 0) # ignore tmpnam warnings

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def system(cmd):
    """Run a command, throwing an exception if a non-zero exit code is returned
    Obeys noaction"""

    if noaction:
        print cmd
    else:
        errno = os.system(cmd)
        if errno != 0:
            raise RuntimeError, ("\n\t".join(("Command:\n" + cmd).split("\n")) + ("\nexited with code %d" % (errno >> 8)))

def copyfile(file1, file2):
    """Like shutil.copy2, but don't fail copying a file onto itself"""

    try:
        stat1 = os.stat(file1)
        stat2 = os.stat(file2)
        if \
               stat1[stat.ST_DEV] == stat2[stat.ST_DEV] and \
               stat1[stat.ST_INO] == stat2[stat.ST_INO]:
            return
    except OSError:
        pass

    try:
        os.unlink(file2)
    except OSError:
        pass

    shutil.copy2(file1, file2)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def currentFile():
    """Return the name of a current-versions file"""
    return "current.list"
    
def manifestFile(product, version):
    """Return the name of a manifest file"""
    return "%s-%s.manifest" % (product, version)

def get_tabledir(transport):
    tabledir = "%s/tables" % (package_base)
    if transport == LOCAL and not os.path.isdir(tabledir):
        print >> sys.stdout, "Creating %s" % (tabledir)
        os.mkdir(tabledir)

    return tabledir

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Handle distribution via tarballs
#
def write_tarball(basedir, product_dir, package_base, product, version):
    """Create a tarball """
    
    tarball = "%s-%s.tar.gz" % (product, version)

    if os.access("%s/%s" % (package_base, tarball), os.R_OK) and not force:
        if verbose > 0:
            print >> sys.stderr, "Not recreating", tarball
        return tarball
    
    if verbose > 0:
        print >> sys.stderr, "Writing", tarball

    try:
        system("cd %s && tar -cf - %s | gzip > %s/%s" % (basedir, product_dir, package_base, tarball))
    except Exception, param:
        print >> sys.stderr, "Failed to write %s/%s" % (package_base, tarball)
        os.unlink("%s/%s" % (package_base, tarball))
        sys.exit(1)

    return tarball

def install_from_tarball(products_root, package_base, tarball):
    """Retrieve and unpack a tarball"""
    
    tfile = "%s/%s" % (package_base, tarball)
    if transport != LOCAL and not noaction:
        (tfile, msg) = file_retrieve(tfile, transport)

    if not noaction and not os.access(tfile, os.R_OK):
        print >> sys.stderr, "Unable to read %s" % (tfile)
        sys.exit(1)

    if verbose > 0:
        print >> sys.stderr, "installing %s into %s" % (tarball, products_root)

    try:
        system("cd %s && cat %s | gunzip -c | tar -xf -" % (products_root, tfile))                
    except:
        print >> sys.stderr, "Failed to read %s" % (tfile)
        sys.exit(1)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Handle distribution via cvs/svn and explicit build files
#
def write_builder(basedir, product_dir, package_base, product, version, buildFilePath):
    """Given a buildfile (which contains information about its' CVS/SVN root,
    write a small file to the manifest directory allowing us to bootstrap the
    build.  The build file is looked for in buildFilePath, a : separated set of
    directories ("@" -> the installed product's ups directory)"""

    builder = "%s-%s.build" % (product, version)

    foundIt = False
    for bd in buildFilePath.split(":"):
        if bd == "@":
            buildFile = os.path.join(basedir, product_dir, "ups", "%s.build" % product)
        else:
            buildFile = os.path.join(bd, "%s.build" % product)

        if os.path.exists(buildFile):
            foundIt = True
            break;

    if foundIt:
        if verbose:
            print "Using build file %s" % (buildFile)
    else:
        print >> sys.stderr, "I can't find a build file %s.build anywhere on %s" % (product, buildFilePath)
        sys.exit(1)

    builderDir = os.path.join(package_base, "builds")
    if not os.path.isdir(builderDir):
        try:
            os.mkdir(builderDir)
        except:
            print >> sys.stderr, "Pacman failed to create %s" % (builderDir)
            sys.exit(1)
    
    full_builder = os.path.join(builderDir, builder)
    if os.access(full_builder, os.R_OK) and not force:
        if verbose > 0:
            print >> sys.stderr, "Not recreating", full_builder
        return builder
    
    if verbose > 0:
        print >> sys.stderr, "Writing", full_builder

    try:
        if False:
            copyfile(buildFile, full_builder)
        else:
            try:
                ifd = open(buildFile)
            except IOError, e:
                print >> sys.stderr, "Failed to open file \"%s\" for read" % buildFile
                sys.exit(1)

            try:
                ofd = open(full_builder, "w")
            except IOError, e:
                print >> sys.stderr, "Failed to open file \"%s\" for write" % full_builder
                sys.exit(1)

            try:
                eups.expandBuildFile(ofd, ifd, product, version, verbose)
            except RuntimeError, e:
                print >> sys.stderr, "Failed to expand build file \"%s\": %s" % (full_builder, e)
                sys.exit(1)

            del ifd; del ofd
    except IOError, param:
        print >> sys.stderr, "Failed to write %s: %s" % (full_builder, param)
        try:
            os.unlink(full_builder)
        except OSError:
            pass                        # probably didn't exist
        sys.exit(1)

    return "build:" + builder

def install_from_builder(setups, products_root, package_base, builder, build_dir=None):
    """Setups is a list of setup commands needed to build this product"""
    
    tfile = find_file(builder)

    if False:
        if not noaction and not os.access(tfile, os.R_OK):
            print >> sys.stderr, "Unable to read %s" % (tfile)
            sys.exit(1)

    if not build_dir:
        build_dir = os.path.join(products_root, "EupsBuildDir")

    if not os.path.isdir(build_dir):
        if not noaction:
            try:
                os.makedirs(build_dir)
            except OSError, e:
                print >> sys.stderr, "Failed to create %s: %s" % (build_dir, e)
    
    if verbose > 0:
        print >> sys.stderr, "Building %s in %s" % (builder, build_dir)
    #
    # Does this build file look OK?  In particular, does it contain a valid
    # CVS/SVN location?
    #
    (cvsroot, svnroot, url) = get_root_from_buildfile(tfile)
    if not (cvsroot or svnroot or url):
        if force:
            action = "continuing"
        else:
            action = "aborting"
        print >> sys.stderr, "Warning: unable to find a {cvs,svn}root or wget/curl command in %s; %s" % (tfile, action)
        if force:
            return
        else:
            sys.exit(1)
    #
    # Prepare to actually do some work
    #
    cmd = ["cd %s" % (build_dir)]
    cmd += setups

    if verbose > 2:
        cmd += ["set -vx"]
    #
    # Rewrite build file to replace any setup commands by "setup -j" as
    # we're not necessarily declaring products current, so we're setting
    # things up explicitly and a straight setup in the build file file
    # undo our hard work
    #
    try:
        fd = open(tfile)
    except IOError, e:
        print >> sys.stderr, "Failed to open %s: %s" % (tfile, e)
        sys.exit(1)

    for line in fd:
        line = re.sub(r"\n$", "", line) # strip newline

        if re.search("^#!/bin/(ba|k)?sh", line):      # a #!/bin/sh line; not needed
            continue

        line = re.sub(r"^\s*setup\s", "setup -j ", line)
        cmd += [line]

    del fd

    if verbose:
        print "Issuing commands:"
        print "\t", str.join("\n\t", cmd)
    #
    # Write modified (== as run) build file to build_dir
    #
    bfile = os.path.join(build_dir, builder)
    try:
        bfd = open(bfile, "w")
        for line in cmd:
            print >> bfd, line
        del bfd
    except Exception, e:
        os.unlink(bfile)
        print >> sys.stderr, "Failed to write %s" % bfile
        
    system(str.join("\n", cmd))

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Handle distribution via pacman
#
def use_pacman_cache(package, version):
    """Return a pacman cache ID """
    
    return "pacman:%s:%s|version('%s')" % (pacman_cache, package, version)

def install_from_pacman(products_root, cacheID):
    """Install a package using pacman"""

    pacmanDir = "%s" % (products_root)
    if not os.path.isdir(pacmanDir):
        try:
            os.mkdir(pacmanDir)
        except:
            print >> sys.stderr, "Pacman failed to create %s" % (pacmanDir)
            sys.exit(1)

    if verbose > 0:
        print >> sys.stderr, "installing pacman cache %s into %s" % (cacheID, pacmanDir)
    
    try:
        system("""cd %s && pacman -install "%s" """ % (pacmanDir, cacheID))
    except:
        print >> sys.stderr, "Pacman failed to install %s" % (cacheID)
        sys.exit(1)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def file_retrieve(file, transport):
    """Retrieve a file given a specified transport method"""

    if transport == LOCAL:
        return (file, None)
    elif transport == SCP:
        (tfile, msg) = scpretrieve(file)
    elif transport == URL:
        (tfile, msg) = urlretrieve(file)
    else:
        raise RuntimeError, "Unknown transport method: %s" % transport

    atexit.register(os.unlink, tfile)   # clean up

    return (tfile, msg)

def scpretrieve(file):
    """Retrieve a file using scp"""

    tfile = os.tmpnam()

    try:
        system("scp %s %s" % (file, tfile))
    except:
        print >> sys.stderr, "Failed to retrieve %s" % file
        sys.exit(1)

    return tfile, None

def urlretrieve(file):
    """Like urllib's urlretrieve, except use urllib2 to detect 404 errors"""

    try:
        fd = urllib2.urlopen(file); del fd
    except urllib2.HTTPError:
        raise RuntimeError, ("Failed to open URL %s" % file)
    return urllib.urlretrieve(file)

HTTPError = urllib2.HTTPError

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def createLocationList(filename, packagePath):
    """Create a list of places to look"""
    
    locs = []
    if preferFlavor:
        locs.extend(['/%s' % flavor, ''])
    else:
        locs.extend(['', '/%s' % flavor])

    if packagePath is not None:
        if preferFlavor:
            if tag is not None:
                locs.extend(['/%s/%s/%s' % (packagePath, flavor, tag),
                             '/%s/%s' % (packagePath, flavor),
                             '/%s/%s' % (packagePath, tag),
                             '/%s' % (packagePath)])
            else:
                locs.extend(['/%s/%s' % (packagePath, flavor),
                             '/%s' % (packagePath)])
        else:
            if tag is not None:
                locs.extend(['/%s/%s' % (packagePath, tag),
                             '/%s/%s/%s' % (packagePath, flavor, tag),
                             '/%s' % (packagePath),
                             '/%s/%s' % (packagePath, flavor)])
            else:
                locs.extend(['/%s' % (packagePath),
                             '/%s/%s' % (packagePath, flavor)])

    return locs

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

def find_file(filename, packagePath=None):
    """Lookup a filename given a (possibly incomplete) package_base and filename

    N.B. Modifies the global package_base if needs be"""

    global package_base

    locs = createLocationList(filename, packagePath)

    subDirs = [""]
    if re.search('\.build$', filename):
        subDirs += ['builds']
    elif re.search('\.manifest$', filename):
        subDirs += ['manifests']
    elif re.search('\.table$', filename):
        subDirs += ['tables']

    if verbose > 1:
        print >> sys.stderr, "Looking for %s in:" % (filename), \
              str.join("", map(lambda str: "\n   %s%s" % (package_base, str), locs))
            
    if os.path.isfile(filename):
        pass
    elif transport != LOCAL:
        tfile = None
        for loc in locs:
            for sd in subDirs:
                try:
                    extended_package_base = "%s%s" % (package_base, loc)
                    (tfile, msg) = file_retrieve(os.path.join(extended_package_base, sd, filename), transport)
                    package_base = extended_package_base
                    if verbose > 0:
                        print >> sys.stderr, "Found %s in %s" % (filename, package_base)
                    break
                except RuntimeError:
                    pass

        if tfile:
            filename = tfile
        else:
            print >> sys.stderr, \
                     "Failed to find and retrieve filename %s from %s" % \
                     (filename, package_base)
            sys.exit(1)
    else:
        if not package_base:
            package_base = "%s/packages/%s" % (db, flavor)

        tfile = None
        for loc in locs:
            guess = "%s%s/%s" % (package_base, loc, filename)
            if os.path.isfile(guess):
                tfile = guess
                break

        if tfile is None:
            print >> sys.stdout, \
                  "File %s doesn't exist in %s" % (filename, package_base)
            sys.exit(1)

        filename = tfile

    return filename

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def get_root_from_buildfile(buildFile):
    """Given the name of a buildfile, return (cvsroot, svnroot, url);
    presumably only one will be valid"""

    cvsroot = None; svnroot = None; url = None

    try:
        fd = open(buildFile)
    except IOError, e:
        print >> sys.stderr, "Failed to open buildfile \"%s\": %s" % (buildFile, e)
        sys.exit(1)

    for line in fd:
        mat = re.search(r"^\s*export\s+(CVS|SVN)ROOT\s*=\s*(\S*)", line)
        if mat:
            type = mat.group(1); val = re.sub("\"", "", mat.group(2))

            if type == "CVS":
                cvsroot = val
            elif type == "SVN":
                svnroot = val
            else:
                if verbose:
                    print >> sys.stderr, "Unknown root type:", line,

            continue

        mat = re.search(r"^\s*(wget|curl)\s+(--?\S+\s+)*\s*(\S*)", line)
        if mat:
            url = mat.group(3)

    return (cvsroot, svnroot, url)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def create_distrib(top_product, top_version, dbz, flavor,
                   force, manifest, noaction, transport, verbose):
    """Create a distribution"""

    if not os.path.isdir(package_base):
        if verbose > 0:
            print >> sys.stderr, "Creating", package_base
        try:
            os.makedirs(package_base)
        except:
            print >> sys.stderr, "Failed to create", package_base
            sys.exit(1)

    if not top_version:
        top_version = lookup_current_version(top_product, True, dbz, flavor)

    if noeups:
        productList = [(top_product, top_version, None)]
    else:
        try:
            productList = eups.dependencies(top_product, top_version, dbz)
        except RuntimeError, msg:
            print >> sys.stderr, "".join(msg)
            sys.exit(1)

    products = []
    for (product, version, flavor) in productList:
        if verbose > 1:
            print "Product:", product, "  Flavor:", flavor, "  Version:", version

        if noeups:
            basedir, pdb, pdir = None, None, None
            product_dir = "/dev/null"
            ptablefile = "none"
        else:
            try:
                (pversion, pdb, pdir, pcurrent, psetup) = eups.list(product, version, dbz, flavor)
            except KeyboardInterrupt:
                sys.exit(1)
            except:
                print >> sys.stderr, "WARNING: Failed to lookup directory for", \
                      "product:", product, "  Flavor:", flavor, "  Version:", version
                continue

            try:
                ptablefile = eups.table(product, version, flavor)
                if ptablefile == "":
                    ptablefile = " "
            except KeyboardInterrupt:
                sys.exit(1)                    
            except:
                print >> sys.stderr, "WARNING: Failed to lookup tablefile for", \
                      "product:", product, "  Flavor:", flavor, "  Version:", version
                continue

            if pversion != version:
                print >> sys.stderr, "Something's wrong with %s; %s != %s" % (product, version, pversion)
            #
            # We have the product's directory, and which DB it's registered in
            #
            try:
                (basedir, product_dir) = re.search(r"^(\S+)/(%s/\S*)$" % (product), pdir).groups()
            except:
                if verbose:
                    print >> sys.stderr, "Failed to split \"%s\" into basedir and productdir at \"%s\"" \
                          % (pdir, product)
                if False:
                    print >> sys.stderr, "WARNING: not creating package for %s" % (product)
                    continue
                else:
                    basedir = ""; product_dir = pdir

        if pacman:
            distID = use_pacman_cache(product, version)
        elif buildFilePath:
            distID = write_builder(basedir, product_dir, package_base, product, version, buildFilePath)
        else:
            distID = write_tarball(basedir, product_dir, package_base, product, version)

        if ptablefile != "none":
            fulltablename = ptablefile
            ptablefile = os.path.basename(ptablefile)
            if ("%s.table" % (product)) != ptablefile:
                tabledir = get_tabledir(transport)
                if verbose > 1:
                    print >> sys.stderr, "Copying %s to %s/%s-%s" % \
                          (fulltablename, tabledir, product, ptablefile)
                copyfile(fulltablename, "%s/%s-%s" % (tabledir, product, ptablefile))

        products += [[product, flavor, version, pdb, pdir, ptablefile, product_dir, distID]]

        if no_dependencies:
            if force:
                break
            else:
                print >> sys.stderr, "Not writing manifest as you omitted dependencies; use --force to write it anyway"
                return
    #
    # Time to write enough information to declare the products
    #
    manifestDir = os.path.join(package_base, "manifests")
    if not os.path.isdir(manifestDir):
        try:
            os.mkdir(manifestDir)
        except:
            print >> sys.stderr, "Pacman failed to create %s" % (manifestDir)
            sys.exit(1)
    
    if not manifest:
        manifest = os.path.join(manifestDir, manifestFile(top_product, top_version))
        
    if verbose > 0:
        print >> sys.stderr, "Manifest is", manifest

    try:
        if not noaction:
            ofd = open(manifest, "w")
    except:
        print >> sys.stderr, "Failed to open", manifest
        sys.exit(1)

    if not noaction:
        print >> ofd, "EUPS distribution manifest for %s (%s). Version %s" % \
              (top_product, top_version, eups_distrib_version)
        
    rproducts = products[:]; rproducts.reverse() # reverse the products list
    for p in rproducts:
        (product, flavor, version, pdb, pdir, ptablefile, product_dir, distID) = p
        if not flavor:
            flavor = "NULL"
        if not noaction:
            print >> ofd, str.join("\t", [product, flavor, version, ptablefile, product_dir, distID])

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def lookup_current_version(product, from_eups = True, dbz = None, flavor = None):
    """Attempt to lookup a package's current version, as declared using eups_distrib"""

    if from_eups:
        return eups.current(product, dbz, flavor)
    else:
        try:
            products = read_current(find_file(currentFile()))

            for p in products:
                (name, version) = p
                if name == product:
                    return version
        except:
            pass

    return ""

def read_current(current):
    """Read a list of current products from file current"""

    fd = open(current, "r")

    line = fd.readline()
    mat = re.search(r"^EUPS distribution current version list. Version (\S+)\s*$", line)
    if not mat:
        print >> sys.stderr, "First line of file %s is corrupted:\n\t%s" % (current, line),
        sys.exit(1)
    version = mat.groups()[0]
    if version != eups_distrib_version:
        print >> sys.stderr, "WARNING. Saw version %s; expected %s", version, eups_distrib_version
        
    products = []
    for line in fd:
        line = line.split("\n")[0]
        if re.search(r"^\s*#", line):
            continue

        try:
            (product, flavor, version) = re.findall(r"\S+", line)[0:3]
        except:
            print >> sys.stderr, "Failed to parse line:", line,
            sys.exit(1)

        products += [(product, version)]

    return products

def write_current(current, products, noaction = False):
    """Write a list of current products to file current"""

    try:
        if not noaction:
            ofd = open(current, "w")
    except IOError:
        print >> sys.stderr, "Failed to open", current
        sys.exit(1)

    if verbose > 1:
        print >> sys.stderr, "Writing current product list to", current

    if not noaction:
        print >> ofd, "EUPS distribution current version list. Version %s" % (eups_distrib_version)

    for p in products:
        (product, version) = p[0:2]
        if not noaction:
            print >> ofd, str.join("\t", [product, flavor, version])

def create_current(top_product, top_version, dbz, flavor,
                   noaction, verbose):
    """Create a list of packages that are declared current to eups distrib"""

    current = "%s/%s" % (package_base, currentFile())

    if top_product == "":               # update entire current list
        products = []
    else:
        try:
            products = read_current(current)
        except:
            products = []

        nproducts = []
        for p in products:
            if p[0] != top_product:
                nproducts += [p]
        products = nproducts
    #
    # Extract the up-to-date information about current versions,
    # and add it to the previously existing list [if any]
    #
    if top_version:
        dp = [(top_product, top_version)]
        try:
            info = eups.list(top_product, top_version, dbz, flavor)
        except:
            print >> sys.stderr, "WARNING: failed to find a version \"%s\" of product %s" % \
                  (top_version, top_product)
    else:
        dp = [(top_product, eups.current(top_product, dbz, flavor))]
        
    products += dp

    if top_product and verbose:
        (product, version) = dp[0]
        assert (product == top_product)
        print >> sys.stderr, "Declaring version %s of %s current to eups distrib" % (version, product)
    #
    # Now write the file containing current version info
    #
    write_current(current, products, noaction)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def read_manifest(top_product, top_version, db, dbz, flavor,
                  force, manifest, noaction, transport, verbose):
    """Read a manifest and return products_root, top_version, and a list of products"""

    global package_base

    products_root = db
    flavor_dir = "%s/%s" % (db, flavor)    # where to install
    if True or os.path.isdir(flavor_dir): # Always use the flavor_dir as products_root
        products_root = flavor_dir

    if not manifest:
        if not top_version:
            top_version = lookup_current_version(top_product, from_eups = False)

            if top_version == "":
                print >> sys.stderr, ("No version of %s is declared current to eups distrib\n" + \
                      "Please specify a version or a manifest file with -m") % (top_product)
                sys.exit(1)

            print >> sys.stderr, "Installing %s of %s" % (top_version, top_product)

        raw_manifest = manifestFile(top_product, top_version)
        manifest = find_file(raw_manifest)

        if transport == LOCAL:
            mat = re.search(r"^(.*)/([^/]+)$", manifest)
            if mat:
                pb = mat.groups()[0]
                if package_base and pb != package_base:
                    print >> sys.stderr, "Manifest file %s has different base from -r %s" % \
                          (manifest, package_base)
                package_base = pb
    #
    # OK, we've found the manifest (phew)
    #
    if verbose > 0:
        if manifest == raw_manifest:
            print >> sys.stderr, "Manifest is", manifest
        else:
            print >> sys.stderr, "Manifest is", raw_manifest, "(%s)" % manifest
    if verbose > 2:
        try:
            fd = open(manifest, "r")
            print "Manifest file:\n", "".join(fd.readlines()),
            del fd
        except:
            pass

    try:
        fd = open(manifest, "r")
    except:
        print >> sys.stderr, "Failed to open", manifest
        sys.exit(1)

    line = fd.readline()
    mat = re.search(r"^EUPS distribution manifest for (\S+) \((\S+)\). Version (\S+)\s*$", line)
    if not mat:
        print >> sys.stderr, "First line of file %s is corrupted:\n\t%s" % (manifest, line),
        sys.exit(1)
    version = mat.groups()[2]
    if version != eups_distrib_version:
        print >> sys.stderr, "WARNING. Saw version %s; expected %s" % (version, eups_distrib_version)

    products = []
    for line in fd:
        line = line.split("\n")[0]
        if re.search(r"^\s*#", line):
            continue

        try:
            products += [re.findall(r"\S+", line)[0:6]]
        except:
            print >> sys.stderr, "Failed to parse line:", line,
            sys.exit(1)

    return products_root, top_version, products

def install_distrib(top_product, top_version, db, dbz, flavor,
                    force, manifest, noaction, transport, verbose):
    """Install a set of packages"""

    global package_base

    products_root, top_version, products = read_manifest(top_product, top_version, db, dbz, flavor,
                                                         force, manifest, noaction, transport, verbose)
    if os.path.isdir(products_root):
        if verbose > 0:
            print >> sys.stderr, "Installing products into", products_root

    setups = []                         # setups that we've acquired while processing products
    for (product, mflavor, version, tablefile, product_dir, distID) in products:
        if (no_dependencies and 
            (product != top_product or version != top_version)):
            continue
        
        info = []
        if not noeups:
            try:
                info = eups.list(product, version, dbz, flavor)
            except IndexError:
                pass

        if info and len(info) > 0 and info[0] != "LOCAL":
            setups += ["setup %s %s" % (product, version)]
            
            if current and not force:
                eups.declareCurrent(product, version, flavor, dbz, noaction)
                continue
            else:
                print >> sys.stderr, "Product %s (version %s, flavor %s) is already declared" % \
                      (product, version, flavor)
                if force:
                    print >> sys.stderr, "Reinstalling %s anyway" % (product)
                    eups.undeclare(product, version, flavor, dbz, current, noaction)
                else:
                    continue
        #
        # We need to install and declare this product
        #
        method = None
        mat = re.search(r"(build|pacman):(.*)", distID)
        if mat:
            method = mat.group(1)
            cacheID = mat.group(2)

        if method == "pacman":
            install_from_pacman(products_root, cacheID)
        elif method == "build":
            try:
                install_from_builder(setups, products_root, package_base, cacheID, tmp_dir)
                setups += ["setup %s %s" % (product, version)]
            except Exception, e:
                print >> sys.stderr, e
                sys.exit(1);
        else:
            install_from_tarball(products_root, package_base, distID)
        #
        # We may be done
        #
        if noeups:
            return
        #
        # we need to see if someone (e.g. the pacman script) declared the package for us
        #

        dodeclare = True

        declared = eups.list(product, version, dbz, flavor)
        if declared and len(declared) > 0 and declared[0] != "LOCAL":
            dodeclare = False
        #
        # Deal with table files if not in product root (i.e. -M files)
        #
        # If the table in the manifest file is not "<product>.table" in the manifest file
        # the table file should be installed by eups_distrib and declared via eups declare -M
        #
        if dodeclare:
            if tablefile != "none":
                if ("%s.table" % (product)) != tablefile:
                    tablefile = "%s-%s" % (product, tablefile)
                    if not noaction:
                        tablefile = find_file(tablefile, "%s/%s" % (product, version))

            eups.declare(product, version, flavor, dbz, tablefile,
                         products_root, product_dir, current, noaction)
        else:                           # we may still need to declare it current
            if current:
                eups.declareCurrent(product, version, flavor, dbz, noaction)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Deal with arguments
#
options = dict([
    ["-b", (False, "--prefer-flavor", "Prefer distributions that are flavor-specific")],
    ["-B", (True,  "--build", "Search for build files on this :-separated path\n\t\t(@ -> product's installed ups directory)")],
    ["-C", (False, "--current", "Create a list of current versions which -i can use")],
    ["-c", (False, "--create", "Create a package for distribution")],
    ["-F", (False, "--force", "Force requested behaviour (e.g. redeclare a product)")],
    ["-f", (True,  "--flavor", "Use this flavor. Default: $EUPS_FLAVOR or `eups_flavor`")],
    ["-h", (False, "--help", "Print this help message")],
    ["-i", (False, "--install", "Extract and install the specified package")],
    ["-j", (False, "--nodepend", "Just install product, but not its dependencies")],
    ["-n", (False, "--noaction", "Don\'t actually do anything")],
    ["-N", (False, "--noeups", "Don\'t attempt to lookup product in eups")],
    ["-p", (True,  "--pacman", "Use this pacman cache to install packages")],
    ["-r", (True,  "--root", "Location of manifests and tarballs (may be a URL or scp specification).\nDefault: $EUPS_PKGROOT")],
    ["-t", (True,  "--prefer-tag", "Prefer distributions that are tagged with this tag")],
    ["-T", (True,  "--tmp-dir", "Build products in this directory (when --build is specified)")],
    ["-V", (False, "--version", "Print eups version number and exit")],
    ["-v", (False, "--verbose", "Be chattier (repeat for even more chat)")],
    ["-Z", (True,  "--database", "Use this products path. Default: $EUPS_PATH")],
    ["-z", (True,  "--select-db", "Select the product paths which contain this directory.\nDefault: all")],
    ])

aliases = dict([
    ["-i", ["--extract"]],
    ["-Z", ["--with-eups"]],
    ])

try:
    opts = eups.Getopt(options, sys.argv, aliases, "eups_distrib [options] [product [version]]")
except RuntimeError, param:
    print >> sys.stderr, "Error parsing arguments: %s" % param
    sys.exit(1)

if opts.has_option('-h'):
    print >> sys.stderr, "Distribute eups products with their dependencies\n"
    opts.usage()
    sys.exit(0)

if opts.has_option('-B'):
    buildFilePath = opts.options['-B']

preferFlavor = opts.has_option('-b')
current = opts.has_option('-C')
create = opts.has_option('-c')

if opts.has_option('-f'):
    flavor = opts.options['-f']
else:
    flavor = eups.flavor()

force = opts.has_option('-F')

no_dependencies = opts.has_option('-j')

install = opts.has_option('-i')

manifest = None
if opts.has_option('-m'):
    manifest = opts.options['-m']

noeups = opts.has_option('-N')

noaction = opts.has_option('-n')

pacman = False                          # use pacman to install packages?
if opts.has_option('-p'):
    pacman = True
    pacman_cache = opts.options['-p']

URL, SCP, LOCAL = "URL", "SCP", "LOCAL"
transport = LOCAL
if opts.has_option('-r'):
    package_base = opts.options['-r']
elif os.environ.has_key("EUPS_PKGROOT"):
    package_base = os.environ["EUPS_PKGROOT"];
else:
    package_base = None

tag = None
if opts.has_option('-t'):
    tag = opts.options['-t']

tmp_dir = None
if opts.has_option('-T'):
    tmp_dir = opts.options['-T']

if package_base is not None:
    if install and re.search(r"^http://", package_base):
        transport = URL
    elif install and re.search(r"^scp:", package_base):
        transport = SCP
        package_base = re.sub(r"^scp:", "", package_base)

verbose = 0
if opts.has_option('-v'):
    verbose = opts.options['-v']

if opts.has_option('-V'):
    print >> sys.stderr, "Version: %s" % (eups.version())
    sys.exit(0)

try:
    top_product = opts.argv[0]
except IndexError:
    if current:
        top_product = ""
    elif manifest == None:
        print >> sys.stderr, "Please specify a product\n"
        opts.usage()
        sys.exit(1)

try:
    top_version = opts.argv[1]
except IndexError:
    top_version = ""

if len(opts.argv) > 2:
    print >> sys.stderr, "Junk at end of arguments:", " ".join(opts.argv[2:])
    sys.exit(1)    
#
# Figure out which database to use
#
if opts.has_option('-Z'):
    os.environ['EUPS_PATH'] = opts.options['-Z']
    
try:
    eups_path = str.split(os.environ['EUPS_PATH'], ":")
except KeyError:
    print >> sys.stderr, "Please set EUPS_PATH and try again"
    sys.exit(1)

dbz = ""
if opts.has_option('-z'):
    dbz = opts.options['-z']

if dbz:
    db = filter(lambda x: re.search("/%s/" % dbz, x), eups_path)
    if len(db) == 0:
        print >> sys.stderr, "DB %s is not found in EUPS_PATH:" % dbz, str.join(" ", eups_path)
        sys.exit(1)
    elif len(db) == 1:
        db = db[0]
    else:
        print >> sys.stderr, "Choice of DB %s is ambiguous:" % dbz, " ".join(db)
        sys.exit(1)
else:
    db = eups_path[0]

if not os.path.isdir(db):
    print >> sys.stderr, "Products directory %s doesn't exist" % db
    sys.exit(1)
#
# Check that eups is installed in that db
#
if not os.path.isdir(db + "/ups_db"):
    print >> sys.stderr, "Products database %s/ups_db doesn't exist; please install eups" % db
    sys.exit(1)

if not package_base:
    package_base = os.path.join(db, "packages")
#
# To work
#
if create + install != 1:
    print >> sys.stderr, "Please specify exactly one of --create and --install"
    sys.exit(1)

if create:
    if noeups and not top_version:
        print >> sys.stderr, "You must specify a version if you use --noeups"
        sys.exit(1)

    create_distrib(top_product, top_version, dbz, flavor,
                   force, manifest, noaction, transport, verbose)
    if current:
        create_current(top_product, top_version, dbz, flavor,
                       noaction, verbose)
elif install:
    install_distrib(top_product, top_version, db, dbz, flavor,
                    force, manifest, noaction, transport, verbose)
