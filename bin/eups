#!/usr/bin/env python
#
# The main eups programme
#
import os, re, sys, traceback
import pdb
import eups
import eups, eupsServer
import eupsDistribBuilder
from eupsDistribution import Distribution, DistributionSet
import eupsGetopt
import eupsTable
from eupsServer import ServerConf
from eupsDistribFactory import DistribFactory

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

distribClasses = {}
try:
    for startupFile in os.environ["EUPS_STARTUP"].split(':'):
        try:
            if startupFile:
                execfile(startupFile)
        except Exception, e:
            print >> sys.stderr, "Detected error sourcing %s: %s" % (startupFile, e)
except KeyError:
    pass

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Deal with arguments
#
# Flags that don't really have short forms are specified with non-printable options
#
debugFlag = "-\001"
# for eups distrib:
nobuildFlag = "-\002"
nocleanFlag = "-\003"
# for eups remove
noInteractiveFlag = "-\002"

allowedDebugOptions = ["raise"]

options = {
    "-F" : (False, "--force", "Force requested behaviour"),
    "-f" : (True,  "--flavor", "Use this flavor. Default: $EUPS_FLAVOR or `eups flavor`"),
    "-h" : (False, "--help", "Print this help message"),
    "-n" : (False, "--noaction", "Don\'t actually do anything"),
    "-V" : (False, "--version", "Print eups version number and exit"),
    "-v" : (False, "--verbose", "Be chattier (repeat for even more chat)"),
    "-Z" : (True,  "--database", "Use this products path. Default: $EUPS_PATH"),
    "-z" : (True,  "--select-db", "Select the product paths which contain this directory.\nDefault: all"),
    debugFlag : (True,  "--debug", "Permitted Values: %s" % " ".join(allowedDebugOptions)),
    }
aliases = {
    "-Z" : "--with-eups",
    }

helpStr = """	eups [--help|--version] command [options]
Supported commands are:
	admin		Administer the eups system
	declare		Declare a product
	distrib		Install a product from a remote distribution,
			or create such a distribution 
	expandbuild	Expand variables in a build file
	expandtable	Insert explicit version tags into a table file
	flags		Show the value of \$EUPS_FLAGS
	flavor		Return the current flavor
	list            List some or all products
        path [n]        Print the current eups path, or an element thereof
        pkgroot [n]     Print the current eups pkgroot, or an element thereof
	pkg-config	Return the options associated with product
	remove          Remove an eups product from the system
	undeclare	Undeclare a product
        uses            List everything which depends on the specified product and version
Use
	eups --help cmd
for help with command "cmd"\
"""
#
# Start by looking for our command
#
if len(sys.argv) > 1:
    cmd = sys.argv[1]
else:
    cmd = None

try:
    opts = eupsGetopt.Getopt(options, sys.argv, aliases)
    verbose = opts.options["-v"]
except:
    verbose = 0

eups.commandCallbacks.apply("eups %s" % cmd, sys.argv, verbose)

try:
    opts = eupsGetopt.Getopt(options, sys.argv[:], aliases, helpStr, checkArgs=False)
except RuntimeError, param:
    print >> sys.stderr, "Error parsing arguments: %s" % param
    sys.exit(1)
try:
    cmd = opts.argv[0]
except IndexError:
    cmd = None
#
# Parse arguments common to all sub commands
#
debugOptions = opts.options.get(debugFlag, "").split(":")
for bad in filter(lambda o: o not in [""] + allowedDebugOptions, debugOptions):
    print >> sys.stderr, "\"%s\" in not a valid option to --debug" % bad
allowRaise = "raise" in debugOptions

dbz = opts.options.get('-z')
flavor = opts.options.get('-f', eups.flavor())
force = opts.options.get('-F', False)
noaction = opts.options.get('-n')
path = opts.options.get('-Z')
verbose = opts.options.get('-v')
if not verbose:  verbose = 0
#
# Choose arguments based on cmd
#
if cmd:
    helpStr = "eups [commonOptions] %s [options]" % cmd

subcmd_uses_version = False;            # subcommand uses the "--version" flag
if cmd == "admin":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, "buildCache | clearCache | listCache | clearLocks | clearServerCache")
    options["-r"] = (True,  "--root", "Location of manifests/buildfiles/tarballs (may be a URL or scp specification).\nDefault: $EUPS_PKGROOT")
elif cmd == "declare":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, None, ["product", "version"])
    helpStr += "\n\nDeclare a product"

    options["-c"] = (False,  "--current", "Declare product current")
    options["-m"] = (True,  "--table", "Use table file (may be \"none\") Default: product.table")
    options["-M"] = (True,  None,
                     "Import the given table file directly into the database\n(may be \"-\" for stdin)")
    options["-r"] = (True,  "--root", "Location of product being declared")
    options["-t"] = (True,  "--tag", "Install versions with this tag (e.g. current or stable)")
elif cmd == "depends":
    print >> sys.stderr, "I think that you meant \"eups list --dependencies\""
    sys.exit(1)
elif cmd == "distrib":
    helpStr = """eups distrib -V
    eups distrib -h
    eups distrib list [options] [product [version]]
    eups distrib install options product [version]
    eups distrib create options product [version]
    eups distrib clean options product version

    Manage packages either as a user (via clean, install, or list) or as 
    a provider (via create).

    Use "eups distrib cmd -h" for subcommand options"""
    
    helpStr, narg = eupsGetopt.declareArgs(helpStr); narg = (0,3)

    if len(opts.argv) < 2:
        if opts.options.get('-h') or opts.options.get('-V'):
            desire = "None"
        else:
            print >> sys.stderr, "You must specify a subcommand to eups distrib"
            sys.exit(1)
    else:
        desire = opts.argv[1]
        
    if not desire in ("None", "clean", "create", "install", "list"):
        print >> sys.stderr, "Please choose one of clean, create, install, and list, not %s" % desire
        sys.exit(1)

    options["-F"] = (False, "--force", "Force requested behaviour")
    options["-r"] = (True,  "--root", "Location of manifests/buildfiles/tarballs (may be a URL or scp specification).\nDefault: $EUPS_PKGROOT")
    options["-S"] = (True,  "--server-class", "register this DistribServer class (repeat as needed)")
    options["-t"] = (True,  "--tag", "Install versions with this tag (e.g. current or stable)")
    
    if desire in ("clean"):
        options["-R"] = (False, "--remove", "Clean and Remove all remnants of a declared product")
    if desire in ("create"):
        options["-a"] = (True, "--as", "Install")
        options["-B"] = (True,  "--build", "Search for build files on this :-separated path\n(\"\" -> product's installed ups directory)")
        options["-d"] = (True,  "--distribType", "Create a distribution with this type name (e.g. 'tarball', 'builder')")
        options["-D"] = (True,  "--distrib-class", "register this Distrib class (repeat as needed)")
        options["-f"] = (False, "--use-flavor", "Create an installation specialised to the current flavor")
        options["-I"] = (False, "--incomplete", "Allow a manifest including packages we don't know how to install")
        options["-N"] = (False, "--noeups", "Don\'t attempt to lookup product in eups")
        options["-s"] = (True,  "--server-dir", "the directory tree to save created packages under")
    if desire in ("create", "install"):
        options["-j"] = (False, "--nodepend", "Just install product, but not its dependencies")
        options["-C"] = (False, "--current", "Create a list of products that are current; equivalent to --tag=current")
        options["-m"] = (True,  "--manifest", "Use this manifest file")
    if desire in ("install"):
        options["-d"] = (True,  "--declareAs", "Declare installed products with this tag")
        options["-g"] = (True,  "--groupAccess", "Give specified group r/w access to all built packages")
        options[nobuildFlag] = (False, "--nobuild", "Don\'t attempt to build the product; just declare it")
        options[nocleanFlag] = (False, "--noclean", "Don\'t  clean up after successfully building the product")
        options["-T"] = (True,  "--tmp-dir", "Build products in this directory")
elif cmd == "expandbuild":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, "buildFile", "outDir")

    helpStr += """\n
    Expand a .build file as part of installing it.

    If outDir is provided, the expanded file will be written there;
    otherwise it'll be written to stdout unless you specify --inplace."""

    options["-c"] = (True, '--cvs', "Use this CVSROOT")
    options["-i"] = (False, "--inplace", "Modify file in situ")
    options["-p"] = (True, '--product', "The name of the product")
    options["-s"] = (True, '--svn', "Use this SVNROOT")
    subcmd_uses_version = True;
    options["-V"] = (True, "--version", "Specify version that you're installing")

    aliases["-c"] = "--cvsroot"
    aliases["-s"] = "--svnroot"
elif cmd == "expandtable":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, "tableFile", "outDir")

    helpStr += """\n
Modify a ups table file, replacing setupRequired and setupOptional
lines which refer to the current version by the actual version number 
of the currently setup product; e.g.
      setupRequired(astroda)
becomes
      setupRequired(astroda v13_1)

You can override the version with e.g. -p astroda=rhl; more
than one -p command is permitted.

If a directory is specified, the modified table file will be written
there, with the same name as the original; otherwise it is written to
standard out unless you specify --inplace, in which case the
substitution will be done in situ.  You may omit file.table, or
specify it as "-", to read standard input; this implies --inplace.
    
For example, the make target in a ups directory might contain the line:
      eups expandtable -w iop.table $(IOP_DIR)/ups
    
    """

    options["-i"] = (False, "--inplace", "Modify file in situ")
    options["-p"] = (True, '--product', "The version of the product")
    options["-w"] = (False, "--warn", "Warn about versions with non-canonical names")
    options["-W"] = (True, "--warnRegexp", "Canonical versions should match this regexp (implies --warn)")
elif cmd == "flags":
    helpStr, narg = eupsGetopt.declareArgs(helpStr)
    helpStr += "\n\nPrint the value of EUPS_FLAGS"
elif cmd == "flavor":
    helpStr, narg = eupsGetopt.declareArgs(helpStr)
    helpStr += "\n\nPrint your eups flavor"
elif cmd == "list":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, None, ["product", "version"])
    helpStr += "\n\nPrint information about products"

    options["-c"] = (False,  "--current", "Only show current products")
    options["-d"] = (False,  "--directory", "Print product directory")
    options["-D"] = (False,  "--dependencies", "Print product's dependencies")
    options["-e"] = (False,  "--exact", "Use the as-installed version, not the conditional in the table file")
    options["-m"] = (False,  "--table", "Print name of table file")
    options["-s"] = (False,  "--setup", "Only show setup products")
    options["-t"] = (True,  "--tag", "List versions with this tag (e.g. current or stable)")
    options["-T"] = (True,  "--type", "Specify type of setup (permitted values: build)")
    subcmd_uses_version = True;
    options["-V"] = (False,  "--version", "Print the version")
elif cmd == "path" or cmd == "pkgroot":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, None, "index")
    helpStr += "\n\nPrint the eups %s; with index print just one element (-ve: from end)" % cmd
elif cmd == "startup":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, None, "index")
    helpStr += "\n\nPrint the startup files (as specified by $EUPS_STARTUP) that eups will source;\nwith index print just one element (-ve: from end)"
elif cmd == "pkg-config":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, ["product"], ["version"])
    helpStr += "\n\nPrint information about products"

    options["-c"] = (False, "--cflags", "Output all pre-processor and compiler flags")
    options["-l"] = (False,  "--libs", "Output all linker flags")
elif cmd == "remove":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, None, ["product", "version"])
    helpStr += "\n\nRemove a product"

    options["-i"] = (False, "--interactive", "Prompt user before actually removing products (default if -R)")
    options[noInteractiveFlag] = (False, "--noInteractive", "Don't prompt user before actually removing products")
    options["-N"] = (False, "--noCheck", "Don't check whether recursively removed products are needed")
    options["-R"] = (False, "--recursive", "Recursively also remove everything that this product depends on")
elif cmd == "setup" or cmd == "unsetup":
    print >> sys.stderr, "Please use the command %s (not \"eups %s\") as you need to modify your environment" % \
          (cmd, cmd)
    sys.exit(1)
elif cmd == "undeclare":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, ["product"], ["version"])
    helpStr += "\n\nUndeclare a product"

    options["-c"] = (False,  "--current", "Stop version from being current")
    options["-t"] = (True,  "--tag", "Undeclare versions with this tag (e.g. current or stable)")
elif cmd == "uses":
    helpStr, narg = eupsGetopt.declareArgs(helpStr, ["product"], ["version"])
    helpStr += "\n\nShow which products setup the specified product (and maybe version of that product)"

    options["-c"] = (False, "--current", "Look for products that setup product only because it's current\n" +
                     "N.b. This isn't the same as specifying product's current version")
    options["-d"] = (True,  "--depth", "Only search down this many layers of dependency")
    options["-e"] = (False,  "--exact", "Use the as-installed version, not the conditional in the table file")
    options["-o"] = (False, "--optional", "Show optional setups")
elif not cmd:
    narg = (0, 0)
else:
    print >> sys.stderr, "Unrecognised eups command: %s" % cmd
    sys.exit(1)    
#
# Parse arguments
#
helpStr += "\n"
try:
    opts = eupsGetopt.Getopt(options, sys.argv, aliases, helpStr, extras=os.environ.get("EUPS_FLAGS"))
except RuntimeError, param:
    print >> sys.stderr, "Error parsing arguments: %s" % param
    sys.exit(1)

if opts.argv:                           # we already found cmd
    opts.argv.pop(0)

if opts.options.get('-V'):
    if subcmd_uses_version:
        pass                            # Uh-oh.  --version is used to specify versions to the subcommand
    else:
        print >> sys.stderr, "Version: %s" % eups.version()
        sys.exit(0)    

if opts.options.get('-h') or not cmd:
    opts.usage()
    sys.exit(0)

if not (narg[0] <= len(opts.argv) <= narg[1]):
    if narg[0] == narg[1]:
        print >> sys.stderr, "Expected %d arguments, saw %d" % (narg[0], len(opts.argv))
    else:
        print >> sys.stderr, "Expected %d--%d arguments, saw %d" % (narg[0], narg[1], len(opts.argv))
    opts.usage()
    sys.exit(1)
#
# Do the work
#
if not cmd:
    usage()
    sys.exit(1)
#
# Do the work
#
def main(cmd, opts):
    if cmd in ["admin", "flavor", "flags", "path"]:
        readCache = False
    else:
        readCache = True
        
    Eups = eups.Eups(flavor=flavor, path=path, dbz=dbz, readCache=readCache, force=force,
                     verbose=verbose, noaction=noaction)

    if cmd == "admin":
        if opts.argv:
            subcmd = opts.argv.pop(0)            
        else:
            subcmd = None

        eupsAdmin(Eups, subcmd)
    elif cmd == "declare":
        productDir = opts.options.get('-r', None)
        tablefile = opts.options.get('-m', None)
        externalTablefile = opts.options.get('-M', None)
        tag = opts.options.get('-t', None)

        Eups.setCurrentType(makeCurrentObject(opts.options.get('-c', False), opts.options.get("-t", None)))

        if opts.argv:
            productName = opts.argv.pop(0)

            if opts.argv:
                versionName = opts.argv.pop(0)
            else:
                versionName = None
        else:
            if productDir:
                rest, versionName = os.path.split(productDir)
                rest, productName = os.path.split(rest)

                if verbose:
                    print >> sys.stderr, "Guessed product/version %s/%s from directory name" % \
                          (productName, versionName)
            else:
                productName = None

        if not productName or not versionName:
            print >> sys.stderr, "Please provide a product and version name"
            sys.exit(1)

        if tablefile and externalTablefile:
            print >> sys.stderr, "You may not specify both -m and -M"
            sys.exit(1)

        if externalTablefile:
            if externalTablefile == "-":
                tablefile = sys.stdin
            else:
                try:
                    tablefile = open(externalTablefile, "r");
                except IOError, e:
                    print >> sys.stderr, ("Error opening %s: %s" % (externalTablefile, e))
                    sys.exit(1)

        Eups.declare(productName, versionName, productDir=productDir, tablefile=tablefile,
                     declareCurrent=Eups.currentType)
    elif cmd == "distrib":
        # We already checked that there was a subcommand, called "desire"
        assert len(opts.argv) and opts.argv.pop(0) == desire;

        if desire == "clean":
            pkgroots = [None]

        if opts.options.get('-C'):      # -C is a synonym for "--tag=current --declareAs=current"
            if opts.options.has_key("-t") and opts.options["-t"] != "current":
                print >> sys.stderr, "You may not specify --current and --tag"
                sys.exit(1)
            opts.options["-t"] = "current"
            if desire == "install":
                opts.options["-d"] = "current" # declare as current too

        manifest = opts.options.get('-m', None)
        tag = opts.options.get('-t', None) # don't call checkValidTag as who knows what tags are out there?
        makeCurrent = opts.options.get('-C', None)
        noeups = opts.options.get('-N', False)
        noclean = opts.options.get(nocleanFlag)
        serverDir = opts.options.get('-s', None)
        nodepend = opts.options.get('-j', False)
        if desire == "create":
            distName = opts.options.get('-d', None)

        installFlavor = flavor
        if cmd == "create" and not opts.options.get("-f", False):
            installFlavor = "generic"

        pkgroots = getPkgroots(opts)
        if desire in ("install", "list") and (len(pkgroots) == 0 and Eups.verbose):
            print >> sys.stderr, "No package root specified; you will not be able install packages"
            sys.exit(1)

        if len(pkgroots) == 0 and noeups:
            print >> sys.stderr, "--noeups option requires package root to be specified (via -r or $EUPS_PKGROOT)"
            sys.exit(1)

        # handle extra options
        dopts = { 'config': {} }
        dopts['noeups']     = noeups
        dopts['noaction']   = opts.options.get('-n', False)
        dopts['nobuild']   = opts.options.get(nobuildFlag, False)
        dopts['noclean']   = opts.options.get(nocleanFlag, False)
        dopts['allowIncomplete'] = opts.options.get('-I', False)
        dopts['buildFilePath'] = opts.options.get('-B', ":")

        if opts.options.get('-T'):
            dopts['buildDir'] = opts.options.get('-T')
        if opts.options.get('-G'):
            dopts['serverconf']['PREFER_GENERIC']  = True
        if opts.options.get('-S'):
            dopts['serverconf']['DISTRIB_SERVER_CLASS']  = True
        if opts.options.get('-D'):
            dopts['serverconf']['DISTRIB_CLASS']  = True
        if opts.options.get('-g'):
            dopts['obeygroups'] = True
            dopts['groupowner'] = opts.options.get('-g')
        
        try:
            productName = opts.argv[0]
        except IndexError:
            if tag == "current":
                productName = ""
            elif desire == "list":
                productName = None
            elif manifest == None:
                print >> sys.stderr, "Please specify a product\n"
                opts.usage()
                sys.exit(1)

        try:
            versionName = opts.argv[1]
        except IndexError:
            versionName = None

        if desire == "list" and Eups.noaction:
            print >> sys.stderr, "You may not specify --noaction with list"
            sys.exit(1)
        #
        # Check that eups is installed in that db
        #
        packageBasePath = []

        if desire == "create" and dopts['noeups'] and distName == "builder" and not dopts['buildFilePath']:
            print >> sys.stderr, \
                  "You must specify a path with --build if you're using --noeups"
            sys.exit(1)


        if desire == "list":
            onlyTag = tag               # only return distributions tagged as tag
        else:
            onlyTag = None

        ds = DistributionSet(Eups, pkgroots, dopts, installFlavor,
                             distribClasses, tag=onlyTag) # all the available Distributions

        if desire == "list":
            for (pkgroot, pkgs) in ds.listPackages(productName, versionName):
                if len(pkgs) > 0:
                    if len(pkgroots) > 0:
                        print "Available products from %s server (%s):" % (ds.primary[pkgroot], pkgroot)
                    for (name, ver, flav) in pkgs:
                        print "  %-20s %-10s %s" % (name, flav, ver)
                else:
                    print "No matching products available from %s server (%s)" % (ds.primary[pkgroot], pkgroot)
        elif desire == "install":
            if productName is None:
                print >> sys.stderr, "Please provide a product to install"
                sys.exit(1)

            installedTag = opts.options.get("-d", None)  # install with this tag
            if installedTag:
                makeCurrent = True
                Eups.setCurrentType(makeCurrentObject(False, installedTag))

            for pkgroot in ds.pkgroots:
                dist = ds.distributions[pkgroot]

                try:
                    dist.install(productName, versionName, makeCurrent, nodepend=nodepend,
                                 manifest=manifest, distributionSet=ds)
                    break
                except eupsServer.RemoteFileNotFound, e:
                    print >> sys.stderr, "Unable to get %s from %s server because: %s" % \
                          (productName, ds.primary[pkgroot], e)

                    if len(pkgroots) > 0 and pkgroot is not pkgroots[-1]:
                        print >> sys.stderr, "Trying next server."
                    else:
                        print >> sys.stderr, "Giving up."
                        sys.exit(1)

                except eupsServer.ServerError, e:
                    msg = "Install failed while pulling data: %s" % e
                    if len(pkgroots) > 0 and pkgroot is not pkgroots[-1]:
                        msg += "; trying next server."
                        print >> sys.stderr, msg
                        sys.exit(1)
                    else:
                        print >> sys.stderr, msg
        elif desire == "create":
            if productName is None or versionName is None:
                print >> sys.stderr, "Please provide a product and version to create"
                sys.exit(1)

            dist = ds.distributions[ds.pkgroots[0]]

            if not serverDir and dist.distServer is not None and \
                 eupsServer.LocalTransporter.canHandle(dist.distServer.base):
                serverDir = dist.distServer.base

            if not serverDir:
                print >> sys.stderr, "Please specify a server directory with -s"
                sys.exit(1)
            if not distName:
                print >> sys.stderr, "Please specify a distribution type name (e.g. -d tarball, -d builder, etc)"
                sys.exit(1)

            dist.create(serverDir, distName, productName, versionName,
                        nodepend=nodepend, manifest=manifest, distributionSet=ds)
        elif desire == "clean":
            uninstall = bool(opts.options.get('-R'))
            flav = opts.options.get('-f', Eups.flavor)

            dist = ds.distributions[ds.pkgroots[0]]
            dist.clean(productName, versionName, flav, uninstall)

    elif cmd in ("expandbuild", "expandtable"):
        productList = {}
        if cmd == "expandbuild":
            fileType = "build"

            cvsroot = opts.options.get('-c', None)
            productName = opts.options.get('-p', "")
            svnroot = opts.options.get('-s', None)
            versionName = opts.options.get('-V')
            if not versionName:
                print >> sys.stderr, "Please specify a version with --version or -V"
                sys.exit(1)

            productList[productName] = versionName
        elif cmd == "expandtable":
            fileType = "table"

            productVersionPair = opts.options.get('-p', None)
            if productVersionPair:
                for pv in productVersionPair.split(":"):
                    p, v = pv.split("=")
                    productList[p] = v
            
            warn = opts.options.get('-w', False)
            warnRegexp = opts.options.get('-W', None)

            if warn and not warnRegexp:
                warnRegexp = "^[vV]"
        else:
            raise AssertionError, "Impossible expansion command: %s" % cmd
        
        in_situ = opts.options.get('-i', False)
        inFile = opts.argv.pop(0)

        if len(opts.argv) == 0:
            outdir = None
        else:
            if in_situ:
                print >> sys.stderr, "You may not specify both --inplace and a target directory"
                sys.exit(1);

            outdir = opts.argv.pop(0)

        if fileType == "build":
            expandFile(Eups, inFile, productList, fileType, outdir=outdir, in_situ=in_situ,
                            svnroot=svnroot, cvsroot=cvsroot)
        elif fileType == "table":
            expandFile(Eups, inFile, productList, fileType, outdir=outdir, in_situ=in_situ,
                            versionRegexp=warnRegexp)
        else:
            raise AssertionError, "Impossible expansion command: %s" % cmd
    elif cmd == "flags":
        try:
            print "EUPS_FLAGS == %s" % (os.environ["EUPS_FLAGS"])
        except KeyError:
            print "You have no EUPS_FLAGS set"
    elif cmd == "flavor":
        print Eups.flavor
    elif cmd == "list":
        current = opts.options.get('-c', False)
        directory = opts.options.get('-d', False)
        dependencies = opts.options.get('-D', False)
        Eups.exact_version = opts.options.get("-e", False)
        tablefile = opts.options.get('-m', False)
        setup = opts.options.get('-s', False)
        setupType = opts.options.get('-T')
        tag = opts.options.get('-t', None)
        showVersion = opts.options.get("-V")

        current = makeCurrentObject(current, tag, checkTag=False)

        productName, versionName = None, None
        if opts.argv:
            productName = opts.argv.pop(0)
        if opts.argv:
            versionName = opts.argv.pop(0)

        if dependencies and not versionName:
            print >> sys.stderr, "You must specify a version when you ask for dependencies"
            sys.exit(1);

        listProducts(Eups, productName, versionName,
                     current=current, setup=setup, tablefile=tablefile, directory=directory,
                     dependencies=dependencies, showVersion=showVersion, setupType=setupType)
    elif cmd == "path" or cmd == "pkgroot" or cmd == "startup":
        if cmd == "path":
            _what = "EUPS_PATH"
            _path = Eups.path
        elif cmd == "pkgroot":
            _what = "EUPS_PKGROOT"
            _path = os.environ.get(_what, "").split("|")
        elif cmd == "startup":
            _what = "EUPS_STARTUP"
            _path = os.environ.get(_what, "").split(":")
            
        try:
            if opts.argv:
                a = opts.argv.pop()
                n = int(a)
                if n < 0:
                    n += len(_path)

                _path = [_path[n]]
        except IndexError:
            print >> sys.stderr, "Element %d of %s doesn't exist" % (n, _what)
            sys.exit(1)
        except ValueError:
            print >> sys.stderr, "Unrecognised argument to eups %s: %s" % (cmd, a)
            sys.exit(1)
        
        for p in _path:
            print p
    elif cmd == "pkg-config":
        cflags = opts.options.get("-c", False)
        libs = opts.options.get("-l", False)

        if cflags + libs != 1:
            print >> sys.stderr, "Please specify exactly one desired item of information"

        if cflags:
            desired = "Cflags"
        elif libs:
            desired = "Libs"
        else:
            print >> sys.stderr, "RHL made a mistake; complain"
            sys.exit(1)

        productName = opts.argv.pop(0)
        if opts.argv:
            versionName = opts.argv.pop(0)
        else:
            versionName = None
        #
        # Time to do some real work
        #
        PKG_CONFIG_PATH = os.environ.get("PKG_CONFIG_PATH", "").split(":")
        productList = Eups.listProducts(productName, versionName)
        #
        # Look for the best match
        productDir = None
        if versionName:
            try:
                name, version, db, productDir, isCurrent, isSetup = productList[0]
            except IndexError:
                pass

        if not productDir:              # try setup version
            for name, version, db, dir, isCurrent, isSetup in productList:
                if isSetup:
                    productDir = dir
                    break

        if not productDir:              # try current version
            for name, version, db, dir, isCurrent, isSetup in productList:
                if isCurrent:
                    productDir = dir
                    break

        if productDir:
            PKG_CONFIG_PATH += [os.path.join(productDir, "etc")]
        
        if not PKG_CONFIG_PATH:
            if versionName:
                print >> sys.stderr, "Unable to find %s %s" % (productName, versionName)
            else:
                print >> sys.stderr, "No version of %s is either setup or current" % (productName)
            sys.exit(1)

        pcfile = None
        for dir in PKG_CONFIG_PATH:
            _pcfile = os.path.join(dir, "%s.pc" % productName)

            if os.path.exists(_pcfile):
                pcfile = _pcfile
                break

        if pcfile:
            if Eups.verbose:
                print >> sys.stderr, "Reading %s" % pcfile
            # Time to actually read and process the file.
            symbols = {}
            contents = open(pcfile).readlines()
            #
            # Look for variable definitions
            #
            for line in contents:
                mat = re.search(r"^\s*([^=\s]+)\s*=\s*([^\s]+)", line)
                if mat:
                    symbols[mat.group(1)] = mat.group(2)
            #
            # Expand references to variables in other variable's values
            #
            for k in symbols.keys():
                mat = re.search(r"(?:^|[^$])\${([^\}]+)}", symbols[k])
                if mat:
                    var = mat.group(1)
                    symbols[k] = re.sub(r"(^|[^$])\${([^\}]+)}", r"\1%s" % symbols[var], symbols[k])
            #
            # Look for configuration values
            #
            for line in contents:
                mat = re.search(r"^\s*%s\s*:\s*(.*)" % desired, line, re.IGNORECASE)
                if mat:
                    value = mat.group(1)
                    
                    mat = re.search(r"(?:^|[^$])\${([^\}]+)}", value)
                    if mat:
                        var = mat.group(1)
                        value = re.sub(r"(^|[^$])\${([^\}]+)}", r"\1%s" % symbols[var], value)


                    value = re.sub(r"\$\$", r"$", value)

                    print value
                    break
        else:
            print >> sys.stderr, "I am unable to find a .pc file for %s" % productName
    elif cmd == "remove":
        recursive = opts.options.get('-R', False)
        interactive = (recursive or opts.options.get('-i', False)) and not opts.options.get(noInteractiveFlag)
        noCheck = opts.options.get('-N', False)

        productName = opts.argv.pop(0)
        if opts.argv:
            versionName = opts.argv.pop(0)
        else:
            versionName = None

        Eups.remove(productName, versionName, recursive, checkRecursive=not noCheck, interactive=interactive)
    elif cmd == "setup" or cmd == "unsetup":
        print "Please use the command \"%s\" which modifies your environment" % " ".join([cmd] + opts + argv)
    elif cmd == "undeclare":
        Eups.setCurrentType(makeCurrentObject(opts.options.get('-c', False), opts.options.get("-t", None)))

        if opts.options.get('-c', False) or opts.options.get("-t", None): # they want to undeclare a tag (inc. current)
            undeclareCurrent = Eups.currentType
        else:
            undeclareCurrent = None
        

        productName = opts.argv.pop(0)
        if opts.argv:
            versionName = opts.argv.pop(0)
        else:
            versionName = None

        Eups.undeclare(productName, versionName, undeclareCurrent=undeclareCurrent)
    elif cmd == "uses":
        current = opts.options.get('-c', False)
        depth = int(opts.options.get('-d', "9999"))
        Eups.exact_version = opts.options.get("-e", False)
        showOptional = opts.options.get('-o', False)

        productName = opts.argv.pop(0)
        if opts.argv:
            if current:
                raise RuntimeError, "You may not specify a version and --current"
            versionName = opts.argv.pop(0)
        else:
            versionName = None

        eupsUses(Eups, productName, versionName, depth, showOptional, current)
    else:
        print "Unknown eups command \"%s\"" % cmd

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def makeCurrentObject(current, tag, checkTag=True):
    """Parse the -c and -t flags, returning a Current object or None"""

    if current:
        if tag:
            print >> sys.stderr, "You specified --current and --tag=%s; ignoring tag" % tag
        return eups.Current()
        
    if tag:
        if checkTag:
            eups.checkValidTag(tag)
            
        return eups.Current(tag)
    else:
        return None

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def getPkgroots(opts):
    """Parse opts and return pkgroots"""
    
    pkgroots = opts.options.get('-r', None)
    if pkgroots is None and os.environ.has_key("EUPS_PKGROOT"):
        pkgroots = os.environ["EUPS_PKGROOT"]
    if pkgroots is None:
        return []

    # pkgroots may be a |-delimited list of URLs
    pkgroots = pkgroots.strip().split('|')

    return pkgroots

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def eupsAdmin(Eups, subcmd):
    if not subcmd:
        print >> sys.stderr, helpStr
        sys.exit(1)

    if subcmd == "buildCache":
        Eups.buildCache()
    elif subcmd == "clearCache":
        Eups.clearCache()
    elif subcmd == "listCache":
        Eups.listCache()
    elif subcmd == "clearLocks":
        Eups.clearLocks()
    elif subcmd == "clearServerCache":
        pkgroots = getPkgroots(opts)
        for pkgroot in pkgroots:
            ds = ServerConf.makeServer(pkgroot, eups=Eups, verbosity=Eups.verbose)
            df = DistribFactory(Eups, ds)
            dist = Distribution(Eups, pkgroot, distFactory=df, verbosity=Eups.verbose)
            
            dist.distServer.clearConfigCache(verbosity=Eups.verbose)
    else:
        print >> sys.stderr, "Unexpected sub-command: %s" % subcmd
        print >> sys.stderr, helpStr
        sys.exit(1)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def listProducts(Eups, productName=None, versionName=None,
                 current=False, setup=False, tablefile=False, directory=False, dependencies=False,
                 showVersion=False, setupType=None):

    productNameIsGlob = productName and re.search(r"[\[\]?*]", productName) # is productName actually a glob?

    productList = Eups.listProducts(productName, versionName, current, setup)
    
    if dependencies:
        Eups._msgs["dependencies"] = {}               # maintain list of printed dependencies
        recursionDepth, indent = 0, ""
        
    productTags = {}                    # list of tags indexed by product

    for name, version, db, productDir, isCurrent, isSetup in productList:
        info = ""

        # look up this product's tags and save them in productTags[name]
        if not productTags.has_key(name):
            productTags[name] = {}
            for currentFile in Eups.Product(name, version, eupsPathDirs=db).currentFileName(all=True):
                cchain = eups.CurrentChain(currentFile)
                try:
                    v = cchain.info[Eups.flavor]["version"]
                except KeyError:
                    continue

                if not productTags[name].has_key(v):
                    productTags[name][v] = []
                productTags[name][v] += [cchain.chain]

            for v in productTags[name].keys(): # sort the tags applied to a given version
                tags = productTags[name][v]
                tags.sort()             # can't use "sorted" in older pythons
                productTags[name][v] = tags

        if dependencies:
            if not info:
                if Eups.verbose or not Eups._msgs["dependencies"].has_key(name):
                    Eups._msgs["dependencies"][name] = version
                    info += "%-40s %s" % (name, version)

            for product, optional, currentRequested, recursionDepth in \
                    Eups.Product(name, version, eupsPathDirs=db).dependencies(recursive=True, recursionDepth=1,
                                                                              setupType=setupType):
                if Eups.verbose or not Eups._msgs["dependencies"].has_key(product.name):
                    Eups._msgs["dependencies"][product.name] = product.version

                    if info:
                        info += "\n"

                    indent = "| " * (recursionDepth/2)
                    if recursionDepth%2 == 1:
                        indent += "|"

                    versionName = product.version
                    try: versionName = versionName()
                    except: pass
                    info += "%-40s %s" % (("%s%s" % (indent, product.name)), versionName)
        elif directory or tablefile:
            if Eups.verbose:
                info += "%-10s" % (version)

            if directory:
                if productDir:
                    info += productDir
                else:
                    info += ""
            if tablefile:
                if info:
                    info += "\t"

                try:
                    table = Eups.Product(name, version, eupsPathDirs=db).table

                    if table.file:
                        info += table.file
                    else:
                        info += "none"
                except RuntimeError, e:
                    print >> sys.stderr, e
                    info += "???"
        elif showVersion:
            info += "%-10s" % (version)
        else:
            if productName and not productNameIsGlob:
                info += "   "
            else:
                info += "%-21s " % (name)
            info += "%-10s" % (version)
            if Eups.verbose:
                info += "%-20s %-55s" % (db, productDir)

            extra = []

            try:
                extra += [" ".join(productTags[name][version])] # any tags applied to this version
            except KeyError:
                pass

            if isSetup:
                extra += ["setup"]
            if extra:
                info += "\t" + " ".join(extra)

        if info:
            print info

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def eupsUses(Eups, productName, versionName, depth, showOptional, current):
    #
    # To work
    #
    userList = Eups.uses(productName, versionName, depth)

    if len(userList) == 0:              # nobody cares.  Maybe the product doesn't exist?
        productList = Eups.listProducts(productName, versionName)
        if len(productList) == 0:
            versionNameStr = versionName
            if versionNameStr:
                versionNameStr += " "
            else:
                versionNameStr = ""
                
            print >> sys.stdout, "Product %s %sisn't declared" % (productName, versionNameStr)
            sys.exit(1)

    fmt = "%-20s %-15s"
    if versionName:                             # we know the product version, so don't print it again
        print fmt % ("product", "version")
    else:
        fmt += " %-15s"
        print fmt % ("product", "version", "%s version" % productName)

    for (p, pv, requestedInfo) in userList:
        #import pdb; pdb.set_trace()
        requestedVersion, optional, currentRequested = requestedInfo

        if optional and not showOptional:
            continue

        if current and not currentRequested:
            continue

        if versionName:
            str = fmt % (p, pv)
        else:
            str = fmt % (p, pv, requestedVersion)

        if showOptional:
            if optional:
                str += "Optional"

        print str

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def expandFile(Eups, inFile, productList, fileType=None, outdir=None, in_situ=False, **kwargs):
    """Expand a build or table file"""

    assert fileType
    
    if fileType == "build":
        assert len(productList.keys()) == 1
        
        productName = productList.keys()[0]
        versionName = productList[productName]

        cvsroot = kwargs.get("cvsroot")
        svnroot = kwargs.get("svnroot")
        #
        # Guess the value of PRODUCT
        #
        if productName:
            pass
        else:
            mat = re.search(r"^([^.]+)\.build$", os.path.basename(inFile))
            if mat:
                productName = mat.group(1)
    elif fileType == "table":
        versionRegexp = kwargs.get("versionRegexp")
    else:
        raise RuntimeError, ("Unknown file type: %s" % fileType)
    #
    # Actually open the file and do the work
    #
    backup = None
    if inFile == "-":
        ifd = sys.stdin
    else:
        try:
            if in_situ:
                backup = inFile + ".bak"
                os.rename(inFile, backup)
                ifd = open(backup, "r")
            else:
                ifd = open(inFile)
        except IOError, e:
            if backup and os.path.exists(backup):
                os.rename(backup, inFile)
                os.unlink(backup)

            print >> sys.stderr, "Failed to open file \"%s\" for read" % inFile
            sys.exit(1)

    if outdir:
        outfile = os.path.join(outdir, os.path.basename(inFile))
        if Eups.verbose:
            print "Writing to %s" % outfile

        try:
            ofd = open(outfile, "w")
        except IOError, e:
            print >> sys.stderr, "Failed to open file \"%s\" for write" % outfile
            sys.exit(1)
    elif in_situ:
        try:
            ofd = open(inFile, "w")
        except Exception:
            if backup and os.path.exists(backup):
                os.rename(backup, inFile)
                os.unlink(backup)
    else:
        ofd = sys.stdout
    #
    # Actually do the work
    #
    try:
        if fileType == "build":
            eupsDistribBuilder.expandBuildFile(ofd, ifd, productName, versionName,
                                               Eups.verbose, svnroot=svnroot, cvsroot=cvsroot)
        elif fileType == "table":
            eupsTable.expandTableFile(Eups, ofd, ifd, productList, versionRegexp)
        else:
            raise AssertionError, ("Impossible fileType: %s" % fileType)
    except Exception:
        if backup and os.path.exists(backup):
            os.rename(backup, inFile)
        raise

    if backup and os.path.exists(backup):
        os.unlink(backup)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

if allowRaise:
    main(cmd, opts)                     # n.b. no try block
else:

    try:
        main(cmd, opts)
    except RuntimeError, e:
        print >> sys.stderr, e
        sys.exit(2)
    except OSError, e:
        print >> sys.stderr, e
        sys.exit(1)
    except eupsServer.ServerError, e:
        print >> sys.stderr, "Server error: ", str(e)
        sys.exit(2)
    except SystemExit, e:
        sys.exit(e.code)
    except KeyboardInterrupt, e:
        print >> sys.stderr, "Keyboard interrupt:", str(e)
        sys.exit(4)
    except Exception, e:
        print >> sys.stderr, "Sorry! Implementation Error: ", str(e)
        sys.exit(3)

sys.exit(0)
