#!/usr/bin/perl
#
# Our reimplementation of ups declare.
#
# Note that this is designed _only_ to
# work with products declared with eups_declare.
# There is some compatibility with older files,
# but this program currently breaks for groups.
#
# Syntax : eups_declare [-f <flavor>] <product> <version> \
#   -r <product root directory> [-c] [-m <table file>]
#
# -c modifies the current chain
#
# If the flavor is not specified, then it is extracted from
# $EUPS_FLAVOR
#
# Nikhil Padmanabhan, Princeton
# January 23rd, 2003
#EUPS : A Unix Versioning System
#Copyright (C) 2003 Nikhil Padmanabhan

#    This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#    as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.

#This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.


#############################

if ($ENV{'EUPS_DIR'} eq "") {
    die "ERROR: EUPS_DIR not set\n";
}
require "$ENV{'EUPS_DIR'}/bin/eups_setup.pm";
import eups_setup;

###############################################################################

sub fix_special {
# This is essential since some of the flavors have special characters in 
# them.
    my $arg = $_[0];
    $arg =~ s/\\/\\\\/g;
    $arg =~ s/\./\\\./g;
    $arg =~ s/\+/\\\+/g;
    $arg =~ s/\(/\\\(/g;
    $arg =~ s/\)/\\\)/g;
    $arg =~ s/\{/\\\{/g;
    $arg =~ s/\}/\\\}/g;
    $arg =~ s/\^/\\\^/g;
    $arg =~ s/\*/\\\*/g;
    $arg =~ s/\?/\\\?/g;
    $arg =~ s/\[/\\\[/g;
    $arg =~ s/\|/\\\|/g;
    return $arg;
}

use File::Spec::Functions;
use POSIX qw(strftime);

#Define a seperator
$sep = "#***************************************";
$name = $ENV{"LOGNAME"};
$now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;

# Get the command line parameters
$opts = {-f => 1, -c => 0, -C => 0, -m => 1, -r => 1,
	 -v => 0, -V => 0, -z => 1, -Z => 1}; # permitted options (1: requires argument)

my $options = eups_parse_argv($opts, \@args, \@words);
my $debug = $ENV{"EUPS_DEBUG"};
$debug = 0 if ($debug eq "");

if ($options eq "-h") {
   usage();
   exit(0);
} elsif ($options < 0) {
   exit(1);
}
#
# Process those arguments
#
$db = eups_find_products();
die "ERROR: PRODUCTS not defined\n" if ($db eq "");

if (defined($$options{-f})) {
   $flavor = $$options{-f}
} elsif (defined($ENV{"EUPS_FLAVOR"})) {
   $flavor = $ENV{"EUPS_FLAVOR"};
}
die "ERROR: No flavor specified\n" if ($flavor eq "");

# Get the root directory

if (defined($$options{-r})) {
   $prodroot = $$options{-r};
   $proddirprefix = "$ENV{'PROD_DIR_PREFIX'}";
   if ($prodroot =~ m/$proddirprefix/) {
       $prodroot =~ s|$proddirprefix/*||;
       print STDERR "WARNING : Making PROD_DIR relative to PROD_DIR_PREFIX\n" if ($debug > 0);
   }
}
die "ERROR: No product directory specified\n" if ($prodroot eq "");

# Do we make this current - and update?
$iscurrent = defined($$options{-c});
$onlycurrent = defined($$options{-C});

# Is there a table file?
if (defined($$options{-m})) {
   $tablefile = $$options{-m};
}

$prod = $words[0];
$vers = $words[1];

die "ERROR : No product specified\n" if ($prod eq "");
die "ERROR : No version specified\n" if ($vers eq "");
if ($tablefile eq "") {
   $tablefile = "$prod.table";
}
die "ERROR : Incorrect table file -- must use $prod.table\n" if (($tablefile ne "$prod.table")&&($tablefile !~ /^none$/i));

# Check to see if an entry exists in the database
# create if not.
$fn = catfile($db,$prod);
if (!(-d $fn)) {
    $retval = mkdir $fn;
    die "ERROR : Unable to create entry in database $fn\n" if (!($retval));
}

$fn = catfile($db,$prod,"$vers.version");
goto CURRENT if (($onlycurrent)&&(-e $fn));

if (-e $fn) {
    $comm = "eups_undeclare -f $flavor $prod $vers";
    system($comm);
}

# Now that any previous declarations are removed
# simply create/append this declaration

$new = (!(-e $fn));
die "ERROR opening/creating file $fn\n" if (!(open FILE, ">>$fn"));
print FILE "FILE = Version\nPRODUCT = $prod\nVERSION = $vers\n$sep\n" if $new;
# An example
#FLAVOR = Linux+2.4
#QUALIFIERS = ""
#  DECLARER = paddy
#  DECLARED = 2003-01-17 02.07.41 GMT
#  MODIFIER = paddy
#  MODIFIED = 2003-01-17 02.07.41 GMT
#  PROD_DIR = /u/products/Linux/foobar/v0_1
#  UPS_DIR = ups
#  TABLE_FILE = foobar.table
print FILE "FLAVOR = $flavor\n";
print FILE "QUALIFIERS = \"\"\n";
print FILE "   DECLARER = $name\n";
print FILE "   DECLARED = $now_string\n";
print FILE "   MODIFIER = $name\n";
print FILE "   MODIFIED = $now_string\n";
print FILE "   PROD_DIR = $prodroot\n";
print FILE "   UPS_DIR = ups\n";
print FILE "   TABLE_FILE = $tablefile\n";
print FILE "$sep\n";
close FILE;

goto END if (!($iscurrent));

# Now fix the current chain 
CURRENT:
$fn = catfile($db,$prod,"current.chain");

# Two cases - if the current chain doesn't exist create it
# otherwise go through the file, update a record if necessary
# or add one.

if (-e $fn) {
# Similar code to that in ups_undeclare
    open FILE, "<$fn" or die "Error reading $fn\n";;
    read FILE, $versinfo, 100000;
    close FILE;
# Now strip out all comments
    $versinfo =~ s/\#.*\n//g;
    $versinfo =~ s/flavor/##FLAVOR/gsi;
    @groups2 = $versinfo =~ m/#(flavor.+?)#/gsi;
# Match the last flavor
    @groups3 = $versinfo =~ m/.*(flavor.+\Z)/gsi;
    @group = (@groups2,@groups3);

    open FILE, ">$fn" or die "Error writing $fn\n";
    print FILE "FILE = Version\nPRODUCT = $prod\nCHAIN=current\n$sep\n";
#Now enter in all groups that don't match the flavor
    $flavor = fix_special($flavor);
    $pattern = "FLAVOR *= *$flavor( |\n)";
    $matched = 0;
    for ($i = 0; ($i<@group);$i++) {
# Both the flavor and the version must match
	if (($group[$i] =~ m/$pattern/gsi)) {
	    $matched = 1;
	    print FILE "FLAVOR = $flavor\n";
	    print FILE "VERSION = $vers\n";
	    print FILE "QUALIFIERS = \"\"\n";
	    print FILE "   DECLARER = $name\n";
	    print FILE "   DECLARED = $now_string\n";
	    print FILE "   MODIFIER = $name\n";
	    print FILE "   MODIFIED = $now_string\n$sep\n";
	} else {
	    print FILE "$group[$i]\n$sep\n";
	}
    }
# Suppose the flavor was never declared...?
    if ($matched == 0) {
	print FILE "FLAVOR = $flavor\n";
	print FILE "VERSION = $vers\n";
	print FILE "QUALIFIERS = \"\"\n";
	print FILE "   DECLARER = $name\n";
	print FILE "   DECLARED = $now_string\n";
	print FILE "   MODIFIER = $name\n";
	print FILE "   MODIFIED = $now_string\n$sep\n";
    }
    close FILE;

} else {
    die "ERROR : opening current chain $fn\n" if (!(open FILE, ">$fn"));
    print FILE "FILE = Version\nPRODUCT = $prod\nCHAIN=current\n$sep\n";
# Another example
#FLAVOR = Linux
#VERSION = v0_1
#QUALIFIERS = ""
#  DECLARER = paddy
#  DECLARED = 2003-01-17 02.07.41 GMT
#  MODIFIER = paddy
#  MODIFIED = 2003-01-17 02.07.41 GMT
    print FILE "FLAVOR = $flavor\n";
    print FILE "VERSION = $vers\n";
    print FILE "QUALIFIERS = \"\"\n";
    print FILE "   DECLARER = $name\n";
    print FILE "   DECLARED = $now_string\n";
    print FILE "   MODIFIER = $name\n";
    print FILE "   MODIFIED = $now_string\n$sep\n";
    close FILE;
}


END:
exit;

###############################################################################
#
# Print Help message
#
sub usage
{
   warn <<"EOT";
Usage:
   eups_declare [options] product version
EOT
    eups_show_options($opts);
}
