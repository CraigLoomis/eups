#!/usr/bin/perl
#
# Our reimplementation of ups declare.
#
# Note that this is designed _only_ to
# work with products declared with eups_declare.
# There is some compatibility with older files,
# but this program currently breaks for groups.
#
# Syntax : eups_declare [-f <flavor>] <product> <version> \
#   -r <product root directory> [-c] [-m <table file>]
#
# -c modifies the current chain (and -r may be omitted if the version's been declared)
#
# If the flavor is not specified, then it is extracted from
# $EUPS_FLAVOR
#
# Nikhil Padmanabhan, Princeton
# January 23rd, 2003
#EUPS : A Unix Versioning System
#Copyright (C) 2003 Nikhil Padmanabhan

#    This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#    as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.

#This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.


#############################

BEGIN {
    if ($ENV{'EUPS_DIR'} eq "") {
	die "ERROR: EUPS_DIR not set\n";
    }

    require "$ENV{'EUPS_DIR'}/bin/eups_setup.pm";
    import eups_setup;
}

###############################################################################

use File::Spec::Functions;
use File::Copy;
use POSIX qw(strftime);

#Define a seperator
$sep = "#***************************************";
$name = $ENV{"LOGNAME"};
$now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;

# Get the command line parameters
$opts = {-f => 1, -F => 0, -c => 0, -m => 1, -n => 0, -M => 1, -r => 1,
	 -v => 0, -V => 0, -z => 1, -Z => 1}; # permitted options (1: requires argument)

my $options = eups_parse_argv($opts, \@args, \@words);
my $debug = $ENV{"EUPS_DEBUG"};
$debug = 0 if ($debug eq "");

if ($options eq "-h") {
   usage();
   exit(0);
} elsif ($options < 0) {
   exit(1);
}

#
# Process those arguments
#
$noaction = defined($$options{-n}) ? 1 : 0; # don't actually do anything
if (defined($$options{-f})) {
   $flavor = $$options{-f}
} elsif (defined($ENV{"EUPS_FLAVOR"})) {
   $flavor = $ENV{"EUPS_FLAVOR"};
}
if(!$flavor) {
   chomp($flavor = `$ENV{"EUPS_DIR"}/bin/eups_flavor`);
}
die "ERROR: No flavor specified\n" if ($flavor eq "");

if (defined($$options{-r})) {
   my($prod_dir) = $$options{-r};

   if ($prod_dir ne "none" && $prod_dir !~ m|^/|) {
      use Cwd;
      if ($prod_dir eq ".") {
	 $prod_dir = getcwd();
      } else {
	 $prod_dir = catfile(getcwd(), $prod_dir);
      }

      # handle "-r ../../foo"
      while ($prod_dir =~ s|[^/]+/\.\./||) {
	 ;
      }
      
      $$options{-r} = $prod_dir;
   }
}

# Do we make this current - and update?
$make_current = defined($$options{-c});
$force = defined($$options{-F}); # redeclare if needs be

# Avoid rewriting  file if not necessary. Otherwise we would have to
# read and parse the existing file. In any case I don't believe we do the 
# right thing if only -r is specified and -m/-M is not.
my ($doredeclare) = (defined($$options{-r}) or defined($$options{-M}) or defined($$options{-m})
		     and defined($$options{-F}));

# If the product and version are not specified, try to guess them from the -r path.
$prod = $words[0];
$vers = $words[1];
if ($vers eq "") {
   my($prod_dir) = $$options{-r};
   my($prod_from_tablefile);	# product name guessed from tablefile name

   if (-d $prod_dir && -d "$prod_dir/ups") { # guess product from table file name
      my(@products) = grep(s|^.*/([^/]+)\.table$|\1|, glob("$prod_dir/ups/*.table"));
      my $nproduct = @products;
      
      if ($nproduct == 0) {
	 ;
      } elsif ($nproduct == 1) {
	 $prod_from_tablefile = $products[0];
      } else {
	 warn "I can't guess which product you want; ups directory defines: " . join(" ", @products) . "\n";
      } 
   }

   if ($prod eq "") {
      if ($prod_dir =~ m|([^/]+)/([^/]+)$|) {
	 ($prod, $vers) = ($1, $2);
	 if ($prod && $prod_from_tablefile && $prod ne $prod_from_tablefile) {
	    die "ERROR: guessed product = $prod; version = $vers, but tablefile is for $prod_from_tablefile\n";
	 }
      }
   } else {
      $vers = $prod;
      $prod = $prod_from_tablefile;
   }
   
   warn "INFO: Guessing product = $prod; version = $vers\n" if($debug > 0);
}
die "ERROR : No product specified\n" if ($prod eq "");
die "ERROR : No version specified\n" if ($vers eq "");

# Get the DB and product root directory
my @dbroots = eups_find_roots();
my ($dbroot, $prodroot, $Xversion, $Xtablefile) =
    find_best_version(@dbroots, $prod, $vers, 0, $flavor, 0);
if (not $dbroot) {
    $dbroot = $dbroots[0];		# Just use the first one.
}
my ($prodfound) = $prodroot;

if (defined($$options{-r})) {
   $new_root = 1;		# they specified a new root
   $prodroot = $$options{-r};
   if ($prodroot ne "none") {
      die "-r argument $prodroot is not a directory\n" if (not -d $prodroot);
   }
} else {
   $new_root = 0;
   if (!$prodroot) {		# we failed to look this version up; try
      ;				# to guess a prodroot from product/version
      my($dbr);
      foreach $dbr (@dbroots) {
	 $prodroot_candidate = catfile($dbr, $flavor, $prod, $vers);
	 if (! -d $prodroot_candidate) {
	    if ($debug > 1) {
	       warn "Guessed --root $prodroot_candidate but it isn't a directory\n";
	    }
	 } else {
	    warn "Guessing --root $prodroot_candidate\n" if($debug > 0);
	    if (! -d "$prodroot_candidate/ups") { # can't check product from table file name
	       $prodroot = $prodroot_candidate;
	       last;
	    } else {	       
	       my(@products) = grep(s|^.*/([^/]+)\.table$|\1|, glob("$prodroot_candidate/ups/*.table"));
	       my $nproduct = @products;
	    
	       if ($nproduct == 0) {
		  ;
	       } elsif ($nproduct == 1) {
		  my($prod_from_tablefile) = $products[0];
		  if ($prod_from_tablefile ne $prod) {
		     die "ERROR: Declaring product $prod version $vers, but tablefile is for $prod_from_tablefile\n";
		  }
		  $prodroot = $prodroot_candidate;
		  last;
	       } else {
		  warn "I can't guess which product you want; ups directory defines: " . join(" ", @products) . "\n";
		  last;
	       }
	    }
	 }
      }
   }
   if (!$prodroot) {
      if (defined($$options{-M})) {
	 $prodroot = "none"
      } else {
	 die "Failed to find version $vers of $prod for flavor $flavor\n";
      }
   }
}
if ($debug) {
    warn "INFO : Root = \"$prodroot\"\n";
}

die "ERROR: No product directory specified, and version \"$vers\" isn't declared\n" if (!$prodroot);

# Resolve which table file to use...
if (defined($$options{-m}) and defined($$options{-M})) {
    die("Only one of -M and -m can be specified.");
}
# ... a file to be copied into the DB
if (defined($$options{-M})) {
   $copytable_from = $$options{-M};
   if ($copytable_from eq "-") { # Can we assume /dev/stdin exists?
      if (-r "/dev/stdin") {
	 $copytable_from = "/dev/stdin";
      } else {
	 use File::Temp qw/ :mktemp  /;
	 
	 my($FD);
	 ($FD, $copytable_from) = mkstemp("tableXXXXX");

	 while(<>) {
	    print $FD $_;
	 }
	 close FD;
      }
   }   

   $tabledir = "\$UPS_DB/$prod/$flavor";
   $tablefile = "$vers.table";

   die "ERROR : input table file does not exist or is not readable" 
       if (not -r $copytable_from);
} else {
    # ... "none" or ups/$prod.table
    if (defined($$options{-m})) {
	$tablefile = $$options{-m};
    } else {			# The default.
	$tablefile = "$prod.table" if (not defined($tablefile));
    }
    $tabledir = "\$PROD_DIR/ups";
    $copytable_from = undef;
    
    # Can we declare that the table file _must_ be "ups/$prod.table"? Would make 
    # thing simpler ("none" or default).
    die "ERROR : Incorrect table file name -- must use $prod.table or \"none\"\n" 
	if (($tablefile ne "$prod.table") and ($tablefile ne "none"));
    if ($tablefile ne "none" and $new_root) {
	if ($tablefile =~ m|^/|) {
	    $tablepath = $tablefile;
	} else {
	    $tablepath = "$prodroot/ups/$tablefile";
	}
	die "ERROR : Cannot read required table file \"ups/$tablefile\"."
	    if (not -r "$tablepath");
    }
}

#
# Make path relative to selected/best EUPS_PATH
#
if ($prodroot eq "none") {
       ;
} elsif ($prodfound) {
    if ($prodroot =~ m/$dbroot/) {
	$prodroot =~ s|$dbroot/*||;
    } else {
	print STDERR "WARNING : Not making PRODUCT_DIR relative to EUPS_PATH\n";
	print STDERR "          $prodroot : $dbroot\n";
    }
} else {
    foreach $dbr (@dbroots) {
	if ($prodroot =~ s|^$dbr/*||) {
	    $foundroot = 1;

	    # Fixup db to match. If -z or -Z was specified this should still
	    # be OK. But I worry a bit..
	    $dbroot = $dbr;

	    last;
	}
    }
    if (not $foundroot) {
	print STDERR "WARNING : Not making PRODUCT_DIR relative to any part of EUPS_PATH\n";
	print STDERR "          $prodroot : @dbroots\n";
    }
}

#
# If the product's already setup and they are now declaring in a
# different DB it's probably an error; generate a warning
#
if (defined($ENV{uc($prod) . "_DIR"})) {
   my($proddir) = $ENV{uc($prod) . "_DIR"};
   if ($proddir !~ $dbroot) {	# maybe it's a private -r setup?
      my($official_product) = 0;
      foreach $dbr (@dbroots) {
	 if ($proddir =~ /^$dbr/) {
	    $official_product = 1;
	    last;
	 }
      }
      if ($official_product) {
	 warn "WARNING: You are declaring in $dbroot but you have $proddir setup\n";
      }
   }
}

# Check to see if a product directory exists in the database
# create if not.
my $db = catfile($dbroot, 'ups_db');
$dbprod = catfile($db,$prod);
if (!(-d $dbprod)) {
    $retval = mkdir $dbprod;
    die "ERROR : Unable to create entry in database $dbroot ($!)\n" if (!($retval));
}

$fn = catfile($db,$prod,"$vers.version");

#
# Is this version already declared?
#
if ($prodfound and $doredeclare) {
    if ($force) {
	warn "Version $vers is already declared for flavour $flavor; redeclaring\n";
    } else {
	die "Version $vers is already declared for flavour $flavor; not modifying (use --force to override)\n";
    }

    if ($debug) {
	warn "INFO : Undeclaring $prod $vers (flavor: $flavor)\n";
    }
    $comm = "eups_undeclare -f $flavor -Z $dbroot $prod $vers";
    if($noaction) {
       print "$comm\n";
    } else {
       system($comm);
    }
}

if ($copytable_from) {
    # Walk down the product ups_db directory:
    # Create a per-flavor directory if necessary.
    $tablepath = catfile($dbprod, $flavor);
    if (not -d catfile($tablepath)) {
	$retval = mkdir $tablepath;
	die "ERROR : Unable to create directory for product $prod ups file\n" if (not $retval);
    }

    # And put the table file into that directory.
    $tablepath = catfile($tablepath, $tablefile);
    if(!$noaction) {
       unlink($tablepath);		# although it may not exist
       copy($copytable_from, $tablepath);
    }
}

# Now that any previous declarations are removed simply create/append
# this declaration
#
# An example
#FLAVOR = Linux
#QUALIFIERS = ""
#  DECLARER = paddy
#  DECLARED = 2003-01-17 02.07.41 GMT
#  MODIFIER = paddy
#  MODIFIED = 2003-01-17 02.07.41 GMT
#  PROD_DIR = /u/products/Linux/foobar/v0_1
#  UPS_DIR = ups
#  TABLE_FILE = foobar.table
if (not -e $fn or $doredeclare) {
   if (-e $fn) {
      warn "INFO : modifying version file $fn for $prod $vers (flavor: $flavor)\n" if ($debug);
      if(!$noaction) {
	 die "ERROR opening file $fn\n" if (!(open FILE, ">>$fn"));
      }
   } else {
      warn "INFO : creating version file $fn for $prod $vers (flavor: $flavor, db: $dbroot)\n" if ($debug);
      if(!$noaction) {
	 die "ERROR creating file $fn\n" if (!(open FILE, ">$fn"));
	 print FILE "FILE = Version\nPRODUCT = $prod\nVERSION = $vers\n$sep\n";
      }
   }
   
   if(!$noaction) {
      print FILE "FLAVOR = $flavor\n";
      print FILE "QUALIFIERS = \"\"\n";
      print FILE "   DECLARER = $name\n";
      print FILE "   DECLARED = $now_string\n";
      print FILE "   MODIFIER = $name\n";
      print FILE "   MODIFIED = $now_string\n";
      print FILE "   PROD_DIR = $prodroot\n";
      print FILE "   UPS_DIR = $tabledir\n";
      print FILE "   TABLE_FILE = $tablefile\n";
      print FILE "$sep\n";
      close FILE;
   }
}

if (!$make_current) {
   exit(0);
}

# Now fix the current chain 
$fn = catfile($db,$prod,"current.chain");

# Two cases - if the current chain doesn't exist create it
# otherwise go through the file, update a record if necessary
# or add one.

if (-e $fn) {
    warn "INFO : Modifying current.chain for $prod $vers (flavor: $flavor)\n";
# Similar code to that in ups_undeclare
    if (!$noaction) {
       open FILE, "<$fn" or die "Error reading $fn\n";;
       read FILE, $versinfo, 100000;
       close FILE;
# Now strip out all comments
       $versinfo =~ s/\#.*\n//g;
       $versinfo =~ s/flavor/##FLAVOR/gsi;
       @groups2 = $versinfo =~ m/#(flavor.+?)#/gsi;
# Match the last flavor
       @groups3 = $versinfo =~ m/.*(flavor.+\Z)/gsi;
       @group = (@groups2,@groups3);

       open FILE, ">$fn" or die "Error writing $fn\n";
       print FILE "FILE = Version\nPRODUCT = $prod\nCHAIN=current\n$sep\n";
#Now enter in all groups that don\'t match the flavor
       $flavor = fix_special($flavor);
       $pattern = "FLAVOR *= *$flavor( |\n)";
       $matched = 0;
       for ($i = 0; ($i<@group);$i++) {
# Both the flavor and the version must match
	  if (($group[$i] =~ m/$pattern/gsi)) {
	     $matched = 1;
	     print FILE "FLAVOR = $flavor\n";
	     print FILE "VERSION = $vers\n";
	     print FILE "QUALIFIERS = \"\"\n";
	     print FILE "   DECLARER = $name\n";
	     print FILE "   DECLARED = $now_string\n";
	     print FILE "   MODIFIER = $name\n";
	     print FILE "   MODIFIED = $now_string\n$sep\n";
	  } else {
	     print FILE "$group[$i]\n$sep\n";
	  }
       }
# Suppose the flavor was never declared...?
       if ($matched == 0) {
	  print FILE "FLAVOR = $flavor\n";
	  print FILE "VERSION = $vers\n";
	  print FILE "QUALIFIERS = \"\"\n";
	  print FILE "   DECLARER = $name\n";
	  print FILE "   DECLARED = $now_string\n";
	  print FILE "   MODIFIER = $name\n";
	  print FILE "   MODIFIED = $now_string\n$sep\n";
       }
       close FILE;
    }
} else {
   warn "INFO : Creating current.chain for $prod $vers (flavor: $flavor)\n" if ($debug);
   if(!$noaction) {
      die "ERROR : opening current chain $fn\n" if (!(open FILE, ">$fn"));
      print FILE "FILE = Version\nPRODUCT = $prod\nCHAIN=current\n$sep\n";
# Another example
#FLAVOR = Linux
#VERSION = v0_1
#QUALIFIERS = ""
#  DECLARER = paddy
#  DECLARED = 2003-01-17 02.07.41 GMT
#  MODIFIER = paddy
#  MODIFIED = 2003-01-17 02.07.41 GMT
      print FILE "FLAVOR = $flavor\n";
      print FILE "VERSION = $vers\n";
      print FILE "QUALIFIERS = \"\"\n";
      print FILE "   DECLARER = $name\n";
      print FILE "   DECLARED = $now_string\n";
      print FILE "   MODIFIER = $name\n";
      print FILE "   MODIFIED = $now_string\n$sep\n";
      close FILE;
   }
}

exit(0);

###############################################################################
#
# Print Help message
#
sub usage
{
   warn <<"EOT";
Usage:
   eups_declare [options] product version
EOT
    eups_show_options($opts, "declare");
}
