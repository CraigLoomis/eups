#!/usr/bin/perl
#
# Our reimplementation of ups declare.
#
# Note that this is designed _only_ to
# work with products declared with eups_declare.
# There is some compatibility with older files,
# but this program currently breaks for groups.
#
# Syntax : eups_declare [-f <flavor>] <product> <version> \
#   -r <product root directory> [-c] [-m <table file>]
#
# -c modifies the current chain (and -r may be omitted if the version's been declared)
#
# If the flavor is not specified, then it is extracted from
# $EUPS_FLAVOR
#
# Nikhil Padmanabhan, Princeton
# January 23rd, 2003
#EUPS : A Unix Versioning System
#Copyright (C) 2003 Nikhil Padmanabhan

#    This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#    as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.

#This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.


#############################

if ($ENV{'EUPS_DIR'} eq "") {
    die "ERROR: EUPS_DIR not set\n";
}
require "$ENV{'EUPS_DIR'}/bin/eups_setup.pm";
import eups_setup;

if (!defined(check_eups_path())) {
   exit(1);
}

###############################################################################

sub fix_special {
# This is essential since some of the flavors have special characters in 
# them.
    my $arg = $_[0];
    $arg =~ s/\\/\\\\/g;
    $arg =~ s/\./\\\./g;
    $arg =~ s/\+/\\\+/g;
    $arg =~ s/\(/\\\(/g;
    $arg =~ s/\)/\\\)/g;
    $arg =~ s/\{/\\\{/g;
    $arg =~ s/\}/\\\}/g;
    $arg =~ s/\^/\\\^/g;
    $arg =~ s/\*/\\\*/g;
    $arg =~ s/\?/\\\?/g;
    $arg =~ s/\[/\\\[/g;
    $arg =~ s/\|/\\\|/g;
    return $arg;
}

use File::Spec::Functions;
use POSIX qw(strftime);

#Define a seperator
$sep = "#***************************************";
$name = $ENV{"LOGNAME"};
$now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;

# Get the command line parameters
$opts = {-f => 1, -F => 0, -c => 0, -m => 1, -r => 1,
	 -v => 0, -V => 0, -z => 1, -Z => 1}; # permitted options (1: requires argument)

my $options = eups_parse_argv($opts, \@args, \@words);
my $debug = $ENV{"EUPS_DEBUG"};
$debug = 0 if ($debug eq "");

if ($options eq "-h") {
   usage();
   exit(0);
} elsif ($options < 0) {
   exit(1);
}

$debug = $ENV{"EUPS_DEBUG"};
$debug = 0 if ($debug eq "");
#
# Process those arguments
#
$db = eups_find_products();
die "ERROR: products database not defined\n" if ($db eq "");

if (defined($$options{-f})) {
   $flavor = $$options{-f}
} elsif (defined($ENV{"EUPS_FLAVOR"})) {
   $flavor = $ENV{"EUPS_FLAVOR"};
}
die "ERROR: No flavor specified\n" if ($flavor eq "");

# Do we make this current - and update?
$make_current = defined($$options{-c});
$force = defined($$options{-F}); # redeclare if needs be

# Is there a table file?
if (defined($$options{-m})) {
   $tablefile = $$options{-m};
}

$prod = $words[0];
$vers = $words[1];

if (($prod eq "" && $vers eq "") && ($$options{-r} =~ m|([^/]+)/([^/]+)$|)) {
   ($prod, $vers) = ($1, $2);
   warn "Guessing product = $prod; version = $vers\n" if($debug > 0);
}

die "ERROR : No product specified\n" if ($prod eq "");
die "ERROR : No version specified\n" if ($vers eq "");
if ($tablefile eq "") {
   $tablefile = "$prod.table";
}
die "ERROR : Incorrect table file -- must use $prod.table\n" if (($tablefile ne "$prod.table")&&($tablefile !~ /^none$/i));

# Get the root directory

if (defined($$options{-r})) {
   $new_root = 1;		# they specified a new root
   $prodroot = $$options{-r};
} else {
   $new_root = 0;
   $prodroot = eups_find_prod_dir($db, $flavor, $prod, $vers);
   if (!$prodroot) {
      die "Failed to find version $vers of $prod for flavor $flavor\n";
   }

   if ($debug) {
      warn "Root = $prodroot\n";
   }
}
die "ERROR: No product directory specified, and version \"$vers\" isn't declared\n" if (!$prodroot);
#
# Check that the table file exists
#
if ($tablefile ne "none" && ! -e $tablefile) {
   if ($tablefile =~ m|^/|) {	# absolute name
      warn "Warning: failed to find \"$tablefile\"\n";
   } else {
      if (! -e "$prodroot/$tablefile" && ! -e "$prodroot/ups/$tablefile") {
	 warn "Warning: \"$tablefile\" is in neither\n" .
	     "\t$prodroot\nnor\n\t$prodroot/ups\n";
      }
   }
}
#
# Make path relative to EUPS_PATH
#
$proddirprefix = "$ENV{'EUPS_PATH'}";
if ($prodroot =~ m/$proddirprefix/) {
   $prodroot =~ s|$proddirprefix/*||;
} else {
   print STDERR "WARNING : Not making PROD_DIR relative to EUPS_PATH\n";
}

# Check to see if an entry exists in the database
# create if not.
$fn = catfile($db,$prod);
if (!(-d $fn)) {
    $retval = mkdir $fn;
    die "ERROR : Unable to create entry in database $fn\n" if (!($retval));
}

$fn = catfile($db,$prod,"$vers.version");

#
# Is this version already declared?
#
if (eups_find_prod_dir($db, $flavor, $prod, $vers)) { # it's already declared
   if ($new_root || !$make_current) {		      # A redeclaration
      if ($force) {
	 warn "Version $vers is already declared for flavour $flavor; redeclaring\n";
      } else {
	 die "Version $vers is already declared; not modifying (use --force to override)\n";
      }
   }

   if ($debug) {
      warn "Undeclaring $prod $vers (flavor: $flavor)\n";
   }
   $comm = "eups_undeclare -f $flavor $prod $vers";
   system($comm);
}

# Now that any previous declarations are removed simply create/append
# this declaration
#
# An example
#FLAVOR = Linux
#QUALIFIERS = ""
#  DECLARER = paddy
#  DECLARED = 2003-01-17 02.07.41 GMT
#  MODIFIER = paddy
#  MODIFIED = 2003-01-17 02.07.41 GMT
#  PROD_DIR = /u/products/Linux/foobar/v0_1
#  UPS_DIR = ups
#  TABLE_FILE = foobar.table
if (-e $fn) {
   die "ERROR opening file $fn\n" if (!(open FILE, ">>$fn"));
} else {
   die "ERROR creating file $fn\n" if (!(open FILE, ">$fn"));
   print FILE "FILE = Version\nPRODUCT = $prod\nVERSION = $vers\n$sep\n";
}

print FILE "FLAVOR = $flavor\n";
print FILE "QUALIFIERS = \"\"\n";
print FILE "   DECLARER = $name\n";
print FILE "   DECLARED = $now_string\n";
print FILE "   MODIFIER = $name\n";
print FILE "   MODIFIED = $now_string\n";
print FILE "   PROD_DIR = $prodroot\n";
print FILE "   UPS_DIR = ups\n";
print FILE "   TABLE_FILE = $tablefile\n";
print FILE "$sep\n";
close FILE;

if (!$make_current) {
   exit(0);
}

# Now fix the current chain 
$fn = catfile($db,$prod,"current.chain");

# Two cases - if the current chain doesn't exist create it
# otherwise go through the file, update a record if necessary
# or add one.

if (-e $fn) {
# Similar code to that in ups_undeclare
    open FILE, "<$fn" or die "Error reading $fn\n";;
    read FILE, $versinfo, 100000;
    close FILE;
# Now strip out all comments
    $versinfo =~ s/\#.*\n//g;
    $versinfo =~ s/flavor/##FLAVOR/gsi;
    @groups2 = $versinfo =~ m/#(flavor.+?)#/gsi;
# Match the last flavor
    @groups3 = $versinfo =~ m/.*(flavor.+\Z)/gsi;
    @group = (@groups2,@groups3);

    open FILE, ">$fn" or die "Error writing $fn\n";
    print FILE "FILE = Version\nPRODUCT = $prod\nCHAIN=current\n$sep\n";
#Now enter in all groups that don't match the flavor
    $flavor = fix_special($flavor);
    $pattern = "FLAVOR *= *$flavor( |\n)";
    $matched = 0;
    for ($i = 0; ($i<@group);$i++) {
# Both the flavor and the version must match
	if (($group[$i] =~ m/$pattern/gsi)) {
	    $matched = 1;
	    print FILE "FLAVOR = $flavor\n";
	    print FILE "VERSION = $vers\n";
	    print FILE "QUALIFIERS = \"\"\n";
	    print FILE "   DECLARER = $name\n";
	    print FILE "   DECLARED = $now_string\n";
	    print FILE "   MODIFIER = $name\n";
	    print FILE "   MODIFIED = $now_string\n$sep\n";
	} else {
	    print FILE "$group[$i]\n$sep\n";
	}
    }
# Suppose the flavor was never declared...?
    if ($matched == 0) {
	print FILE "FLAVOR = $flavor\n";
	print FILE "VERSION = $vers\n";
	print FILE "QUALIFIERS = \"\"\n";
	print FILE "   DECLARER = $name\n";
	print FILE "   DECLARED = $now_string\n";
	print FILE "   MODIFIER = $name\n";
	print FILE "   MODIFIED = $now_string\n$sep\n";
    }
    close FILE;

} else {
    die "ERROR : opening current chain $fn\n" if (!(open FILE, ">$fn"));
    print FILE "FILE = Version\nPRODUCT = $prod\nCHAIN=current\n$sep\n";
# Another example
#FLAVOR = Linux
#VERSION = v0_1
#QUALIFIERS = ""
#  DECLARER = paddy
#  DECLARED = 2003-01-17 02.07.41 GMT
#  MODIFIER = paddy
#  MODIFIED = 2003-01-17 02.07.41 GMT
    print FILE "FLAVOR = $flavor\n";
    print FILE "VERSION = $vers\n";
    print FILE "QUALIFIERS = \"\"\n";
    print FILE "   DECLARER = $name\n";
    print FILE "   DECLARED = $now_string\n";
    print FILE "   MODIFIER = $name\n";
    print FILE "   MODIFIED = $now_string\n$sep\n";
    close FILE;
}

exit(0);

###############################################################################
#
# Print Help message
#
sub usage
{
   warn <<"EOT";
Usage:
   eups_declare [options] product version
EOT
    eups_show_options($opts);
}
