#!/usr/bin/env python
import os, re, sys
import eups
import eupsGetopt

try:
    for startupFile in os.environ["EUPS_STARTUP"].split(':'):
        try:
            if startupFile:
                execfile(startupFile)
        except Exception, e:
            print >> sys.stderr, "Detected error sourcing %s: %s" % (startupFile, e)
except KeyError:
    pass

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Deal with arguments
#
debugFlag = "-\001"
allowedDebugOptions = ["raise"]

options = {
    "-F" : (False, "--force", "Force requested behaviour"),
    "-E" : (False,  "--inexact", "Don't use exact matching even though an explicit version is specified"),
    "-e" : (False,  "--exact", "Use the as-installed version, not the conditional in the table file"),
    "-f" : (True,  "--flavor", "Use this flavor. Default: $EUPS_FLAVOR or `eups_flavor`"),
    "-h" : (False, "--help", "Print this help message"),
    "-i" : (False, "--ignore-versions", "Ignore any explicit versions in table files"),
    "-j" : (False, "--just", "Just setup product, no dependencies (equivalent to --max-depth 0)"),
    "-l" : (False, "--list", "List available versions; not supported --- use \"eups list\""),
    "-k" : (False, "--keep", "Keep any products with local setups (i.e. not in EUPS_PATH)"),
    "-n" : (False, "--noaction", "Don\'t actually do anything"),
    "-N" : (False, "--noCheck", "Don't check whether recursively removed products are needed"),
    "-q" : (False, "--quiet", "Be extra quiet"),
    "-r" : (True,  "--root", "Location of product being setup"),
    "-S" : (True,  "--max-depth", "Only show this many levels of dependencies (use with -v)"),
    "-t" : (True,  "--tag", "Setup version with this tag (e.g. stable)"),
    "-T" : (True,  "--type", "Specify type of setup (permitted values: build)"),
    "-u" : (False, "--unsetup", "Unsetup the specified product"),
    "-V" : (False, "--version", "Print eups version number and exit"),
    "-v" : (False, "--verbose", "Be chattier (repeat for even more chat)"),
    "-Z" : (True,  "--database", "Use this products path. Default: $EUPS_PATH"),
    "-z" : (True,  "--select-db", "Select the product paths which contain this directory.\nDefault: all"),
    debugFlag : (True,  "--debug", "Permitted Values: %s" % " ".join(allowedDebugOptions)),
    }
aliases = {}

try:
    opts = eupsGetopt.Getopt(options, sys.argv, aliases)
    verbose = opts.options["-v"]
except:
    verbose = 0
    
eups.commandCallbacks.apply("setup", sys.argv, verbose)

try:
    opts = eupsGetopt.Getopt(options, sys.argv, aliases, "setup [options] [product [version]]")
except RuntimeError, param:
    print >> sys.stderr, "Error parsing arguments: %s" % param
    sys.exit(1)

if opts.options.get('-h'):
    print >> sys.stderr, "Setup an eups product"
    opts.usage()
    sys.exit(0)

if opts.options.get('-l'):
    print >> sys.stderr, "setup --list is no longer supported; use \"eups list\""
    sys.exit(1)
if opts.options.get('-V'):
    print >> sys.stderr, "Version: %s" % eups.version()
    sys.exit(0)    

debugOptions = opts.options.get(debugFlag, "").split(":")
for bad in filter(lambda o: o not in [""] + allowedDebugOptions, debugOptions):
    print >> sys.stderr, "%s in not a valid option to --debug" % bad

allowRaise = "raise" in debugOptions
dbz = opts.options.get('-z')
inexact_version = opts.options.get("-E", False)
exact_version = opts.options.get("-e", False)
flavor = opts.options.get('-f', eups.flavor())
force = opts.options.get('-F', False)
ignore_versions = opts.options.get("-i", False)
just = opts.options.get("-j", False)
keep = opts.options.get("-k", False)
max_depth = int(opts.options.get("-S", -1))
noaction = opts.options.get('-n')
path = opts.options.get('-Z')
quiet = opts.options.get('-q', 0)
root = opts.options.get('-r')
setupType = opts.options.get('-T')
tag = opts.options.get('-t', None)
unsetup = opts.options.get('-u', False)
verbose = opts.options.get('-v', 0)

if exact_version and inexact_version:
    print >> sys.stderr, "Specifying --exact --inexact confuses me, so I'll ignore both"
    exact_version = False
    inexact_version = False

productName = None
if opts.argv:
    productName = opts.argv.pop(0)

if root:
    try:
        productName = eups.guessProduct(os.path.join(root, "ups"), productName)
    except RuntimeError, e:
        print >> sys.stderr, e
        sys.exit(1)

if opts.argv:
    version = opts.argv.pop(0)
    if tag:
        if verbose > 1:
            print >> sys.stderr, "Using %s although you specified tag %s" % (version, tag)

    if not inexact_version:
        exact_version = True # if they specify a version, that's what they want
else:
    if inexact_version and verbose:
        print >> sys.stderr, "--inexact has no effect unless you request a specific version"

    if unsetup:
        version = None
    else:
        version = eups.Current(tag)

if opts.argv:
    pass

if not productName:
    print >> sys.stderr, "Please specify a product"
    opts.usage()
    sys.exit(1)

if just:
    if max_depth > 0:
        print >> sys.stderr, "You may not specify both --just and --max_depth"    
        sys.exit(1)

    max_depth = 0
#
# Do the work
#
try:
    Eups = eups.Eups(flavor=flavor, path=path, dbz=dbz, root=root, readCache=False, force=force,
                     quiet=quiet, verbose=verbose, noaction=noaction, keep=keep, ignore_versions=ignore_versions,
                     max_depth=max_depth, exact_version=exact_version, currentType=eups.Current(tag))
                          
    cmds = eups.setup(Eups, productName, version, fwd=not unsetup, setupType=setupType)
except RuntimeError, e:
    print >> sys.stderr, e
    if allowRaise:
        raise
    cmds = ["false"]

if Eups.verbose > 2:
    print >> sys.stderr, "\n\t".join(["Issuing commands:"] + cmds)

print ";\n".join(cmds)

