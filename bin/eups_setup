#!/usr/bin/perl
#
# This script calls the appropriate setup/unsetup tasks and update the
# environment variables. It writes it out to a temporary file, which
# can be sourced.
#
# Nikhil Padmanabhan
# Jan 22, 2003 Princeton
#EUPS : A Unix Versioning System
#Copyright (C) 2003 Nikhil Padmanabhan

#    This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#    as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.

#This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
####################

BEGIN {
    if ($ENV{'EUPS_DIR'} eq "") {
	print STDERR "ERROR: EUPS_DIR is not set\n";
	goto CLEAN;
    }
    require "$ENV{'EUPS_DIR'}/bin/eups_setup.pm";
    import eups_setup;
}

use POSIX;

# The subroutines that actually write out the necessary
# shell commands. These subroutines ideally should take care 
# of the shell determination.

sub sete {
    our $shell;
    our $tmpfile;

    my($key, $val) = @_;

    if ($key eq "EUPS_FLAVOR") { # don't propagate -f to the environment!
       return;
    }

    if ($val =~ /\$/) {
	warn "Variable ${key}'s value \"$val\" contains unexpanded variables\n";
    }

    if ($shell eq "sh") {
	print $tmpfile "export $key=\"$val\"\n";
    } elsif ($shell eq "csh") {
        print $tmpfile "setenv $key \"$val\"\n";
    } else {
       die "Unknown shell: $shell\n";
    }
}

sub unsete {
    our $shell;
    our $tmpfile;

    my $key = $_[0];

    if ($key eq "EUPS_FLAVOR") { # don't propagate -f to the environment!
       return;
    }
    
    if ($shell eq "sh") {
        print $tmpfile "unset $key\n";
    } elsif ($shell eq "csh") {
        print $tmpfile "unsetenv $key\n";
    } else {
       die "Unknown shell: $shell\n";
    }
}

sub setshell {
    use File::Basename;
    our $shell = basename($ENV{"SHELL"});

# Do some quick translations
    $shell = "sh" if ($shell eq "bash");
    $shell = "csh" if ($shell eq "tcsh");


    my $retval = 0;
    if ($shell eq "") {
	print STDERR "ERROR : EUPS_SHELL not set\n";
	$retval = -1;

    } elsif (!(($shell eq "sh")||($shell eq "csh"))) {
	print STDERR "ERROR : Unknown shell $shell\n";
	$retval = -1;
    }
    return $retval;
}

#
# Parse arguments. Many are actually interpreted by eups_setup.pm
#
my $op = $ARGV[0]; shift; # desired operation (e.g. "setup")

$opts = {-c => 0, -d => 0, -D => 0, -f => 1, -F => 0, -i => 0, -j => 0,
	 -l => 0, -n => 0, -m => 0, -M => 1, -q => 0, -r => 1, -s => 0,
	 -v => 0, -V => 0, -z => 1, -Z => 1}; # permitted options (1: requires argument)

my $options = eups_parse_argv($opts, \@args, \@words);
# 
if ($options eq "-h") {
   usage();
   &myexit(0);
} elsif ($options < 0) {
   &myexit(1);
}
$current = defined($$options{-c}) ? 1 : 0; # Only process "current" version (default, except for -l)
$debug = $ENV{"EUPS_DEBUG"};
$debug = 0 if ($debug eq "");
$noaction = defined($$options{-n}) ? 1 : 0; # don't actually do anything
$just_directory = 0;
$just_tablefile = 0;
if (defined($$options{-d})) {
   $just_directory = 1;
   $op = "list";
}
$force = defined($$options{-F}) ? 1 : 0;
$flags{ignore_versions} = defined($$options{-i}) ? 1 : 0;
$no_dependencies = defined($$options{-j}) ? 1 : 0;
$only_dependencies = defined($$options{-D}) ? 1 : 0;
if (defined($$options{-l})) {
   $op = "list";
}
if (defined($$options{-m})) {
   $just_tablefile = 1;
   $op = "list";
}
if (defined($$options{-M})) {
   $user_table_file = $$options{-M};
   if (!$only_dependencies) {
      warn "I can't (un)setup a product without a directory/name; assuming --only-dependencies\n" if($debug > 1);
      $only_dependencies = 1;
   }
} else {
   $user_table_file = undef;
}
$setup = defined($$options{-s}) ? 1 : 0; # Only show setup version (default, except for -l)

if($no_dependencies && $only_dependencies) {
   die "It makes no sense to say --just --only-dependencies\n";
}
#
# Can we guess the product from the root?
#
if (!defined($words[0]) && defined($$options{-r})) {
   my($root) = $$options{-r};
   my(@products) =
       grep(s|^.*/([^/]+)\.table$|\1|, glob("$root/ups/*.table"));
   my $nproduct = @products;
   
   if ($nproduct == 0) {
      ;
   } elsif ($nproduct == 1) {
      unshift(@words, $products[0]);
   } else {
      warn "I can't guess which product you want; ups directory defines: " . join(" ", @products) . "\n";
      myexit(1);
   } 
}

@args = ($op, @args, @words);
# Get the command line
$select = $args[0];
$args[0] = "";
$comm = join " ", @args;

if ($user_table_file) {
   if (defined($words[0])) {
      warn"You may not specify a product and an explicit table file; quitting\n";
      &myexit(1);
   }
} elsif (!defined($words[0]) && $op ne "list") {
   warn "Please specify a product\n";
   &usage();
   &myexit(1);
}

# Open the temporary file
our $tmpfile;
if ($noaction) {
   $fn = "/dev/null";
   if(!open $tmpfile, ">$fn") {
      warn "Cannot open $fn for write\n";
      myexit(1);
   }
} else {
   do {
      $fn = tmpnam();
   } until open $tmpfile, ">$fn";
}
#Get the shell 
our $shell = $0;
$retval = setshell;
goto CLEAN if ($retval == -1);
print STDERR "eups -- using shell : $shell\n" if ($debug > 2);

# Die if EUPS_FLAVOR is not set and -f not used and eups_flavor fails...
# this is so that a major failure mode gets a decent error message.
if ($ENV{"EUPS_FLAVOR"} eq "" && !defined($$options{-f})) {
   chomp($flavor = `$ENV{"EUPS_DIR"}/bin/eups_flavor`);
   if ($flavor) {
      $ENV{"EUPS_FLAVOR"} = $flavor;
   } else {
      print STDERR "ERROR: No flavor guessable or specified; use -f or set EUPS_FLAVOR\n";
      goto CLEAN;
   }
}

#Get the environment variables
%oldenv = %ENV;

# Call either setup or unsetup

$status = 0;			# exit status
if ($select eq "list") {
   if($no_dependencies) {
      warn "Option --just makes no sense with --list and is ignored\n";
   }
   if($only_dependencies) {
      warn "Option --only-dependencies makes no sense with --list and is ignored\n";
   }
   eups_list($comm,$tmpfile,$debug,0,$current,$setup,$just_directory,$just_tablefile);
} else {
   if($current) {
      warn "Option --current is always assumed and may be omitted\n";
   }
   if($setup) {
      print STDERR "Option --setup only makes sense with --list\n";
      $status = 1;
      goto CLEAN;
   }
   
   if ($select eq "setup") {
      $retval = eups_setup($comm, $tmpfile, $no_dependencies,
			   $only_dependencies, \%flags, $user_table_file,
			   $debug, 0, 0, \%oldenv, $force);
      if ($retval < 0) {
	 eups_unsetup($comm, $tmpfile, $no_dependencies, 
		      $only_dependencies, \%flags, $user_table_file, $debug, 1);
	 print STDERR "FATAL ERROR: setup failed\n";
	 $status = 2;
	 goto CLEAN;
      }
   } elsif ($select eq "unsetup") {
      $retval = eups_unsetup($comm, $tmpfile, $no_dependencies,
			     $only_dependencies, \%flags, $user_table_file, $debug, 0);
      if ($retval < 0) {
	 if ($debug >= 0) {
	    print STDERR "FATAL ERROR: unsetup$comm failed\n";
	 }
	 $status = 2;
	 goto CLEAN;
      }
   } else {
      print STDERR "ERROR: Unknown command \"$select\" to eups_setup\n";
      $status = 1;
      goto CLEAN;
   }
}

#Check to see and update the environment 

@newkeys = keys %ENV;
@oldkeys = keys %oldenv;

for ($i=0;$i<@oldkeys;$i++) {
# Is the variable still set?
    if (!defined($ENV{$oldkeys[$i]})) {
	unsete($oldkeys[$i]);
	next;
    } 
    $val = $ENV{$oldkeys[$i]};
    $oval = $oldenv{$oldkeys[$i]};
    if (!($val eq $oval)) {
	sete($oldkeys[$i],$val);
	$oldenv{$oldkeys[$i]} = $val; # so we won't set it again below
    }
}

for ($i = 0; $i<@newkeys; $i++) {
    if (!defined($oldenv{$newkeys[$i]})) {
	sete($newkeys[$i],$ENV{$newkeys[$i]});
    }
}

CLEAN:			      # n.b. we can get here without the goto.
if ($debug > 3) {
   warn "Not deleting $fn\n";
} else {
   # Self destruct file
   print $tmpfile "\\rm -f $fn\n";
}
close $tmpfile;

myexit($status, $fn);

###############################################################################

sub myexit
{
   my($exit, $fn) = @_;
   if (!defined($fn)) {
      $fn = "/dev/null";
   }

   if ($status && !$force) {
      if ($debug <= 3) {
	 unlink($fn);
      }

      $fn = "/dev/null";
   }

   print "$fn\n";
   
   exit $exit;
}

###############################################################################
#
# Print Help message
#
sub usage
{
   warn <<"EOT";
EUPS : A Unix Versioning System
CVS Version : $Name: not supported by cvs2svn $

Usage: setup [options] [product [version]]
EOT
    eups_show_options($opts, 1);
}
