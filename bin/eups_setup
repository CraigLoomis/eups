#!/usr/bin/perl
#
# This script calls the appropriate setup/unsetup tasks and update the
# environment variables. It writes it out to a temporary file, which
# can be sourced.
#
# Nikhil Padmanabhan
# Jan 22, 2003 Princeton
#EUPS : A Unix Versioning System
#Copyright (C) 2003 Nikhil Padmanabhan

#    This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#    as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.

#This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
####################

BEGIN {
    if ($ENV{'EUPS_DIR'} eq "") {
	print STDERR "ERROR: EUPS_DIR is not set\n";
	goto CLEAN;
    }
    require "$ENV{'EUPS_DIR'}/bin/eups_setup.pm";
    import eups_setup;
}

use POSIX;

# The subroutines that actually write out the necessary
# shell commands. These subroutines ideally should take care 
# of the shell determination.

sub sete {
    our $shell;
    our $tmpfile;

    my($key, $val) = @_;

    if ($key eq "EUPS_FLAVOR") { # don't propagate -f to the environment!
       return;
    }

    if ($shell eq "sh") {
	print $tmpfile "export $key=\"$val\"\n";
    } elsif ($shell eq "csh") {
        print $tmpfile "setenv $key \"$val\"\n";
    } else {
       die "Unknown shell: $shell\n";
    }
}

sub unsete {
    our $shell;
    our $tmpfile;

    my $key = $_[0];

    if ($key eq "EUPS_FLAVOR") { # don't propagate -f to the environment!
       return;
    }
    
    if ($shell eq "sh") {
        print $tmpfile "unset $key\n";
    } elsif ($shell eq "csh") {
        print $tmpfile "unsetenv $key\n";
    } else {
       die "Unknown shell: $shell\n";
    }
}

sub setshell {
    use File::Basename;
    our $shell = basename($ENV{"SHELL"});

# Do some quick translations
    $shell = "sh" if ($shell eq "bash");
    $shell = "csh" if ($shell eq "tcsh");


    my $retval = 0;
    if ($shell eq "") {
	print STDERR "ERROR : EUPS_SHELL not set\n";
	$retval = -1;

    } elsif (!(($shell eq "sh")||($shell eq "csh"))) {
	print STDERR "ERROR : Unknown shell $shell\n";
	$retval = -1;
    }
    return $retval;
}

#
# Parse arguments. Many are actually interpreted by eups_setup.pm
#
my $op = $ARGV[0]; shift; # desired operation (e.g. "setup")

$opts = {-c => 0, -d => 0, -f => 1, -F => 0, -j => 0, -l => 0, -n => 0, -m => 0, -q => 0, -r => 1, -s => 0,
	 -v => 0, -V => 0, -z => 1, -Z => 1}; # permitted options (1: requires argument)

my $options = eups_parse_argv($opts, \@args, \@words);
# 
if ($options eq "-h") {
   usage();
   &myexit(0);
} elsif ($options < 0) {
   &myexit(1);
}
$current = defined($$options{-c}) ? 1 : 0; # Only process "current" version (default, except for -l)
$debug = $ENV{"EUPS_DEBUG"};
$debug = 0 if ($debug eq "");
$noaction = defined($$options{-n}) ? 1 : 0; # don't actually do anything
$just_directory = 0;
$just_tablefile = 0;
if (defined($$options{-d})) {
   $noaction = 1;
   $just_directory = 1;
   $op = "list";
}
$force = defined($$options{-F}) ? 1 : 0;
$no_dependencies = defined($$options{-j}) ? 1 : 0;
if (defined($$options{-m})) {
   $noaction = 1;
   $just_tablefile = 1;
   $op = "list";
}
if (defined($$options{-l})) {
   $noaction = 1;
   $op = "list";
}
$setup = defined($$options{-s}) ? 1 : 0; # Only show setup version (default, except for -l)

@args = ($op, @args, @words);
# Get the command line
$select = $args[0];
$args[0] = "";
$comm = join " ",@args;

if (!defined($words[0]) && $select ne "list") {
   warn "Please specify a product\n";
   &usage();
   &myexit(1);
}

# Open the temporary file
our $tmpfile;
if ($noaction) {
   $fn = "/dev/null";
   if(!open $tmpfile, ">$fn") {
      warn "Cannot open $fn for write\n";
      myexit(1);
   }
} else {
   do {
      $fn = tmpnam();
   } until open $tmpfile, ">$fn";
}
#Get the shell 
our $shell = $0;
$retval = setshell;
goto CLEAN if ($retval == -1);
print STDERR "eups -- using shell : $shell\n" if ($debug > 2);

# Die if EUPS_FLAVOR is not set and -f not used... this is so that
# a major failure mode gets a decent error message.
if ((1 || $select eq "setup")&&($ENV{"EUPS_FLAVOR"} eq "")&&(!defined($$options{-f}))) {
   chomp($flavor = `$ENV{"EUPS_DIR"}/bin/eups_flavor`);
   if ($flavor) {
      $ENV{"EUPS_FLAVOR"} = $flavor;
   } else {
      print STDERR "ERROR: No flavor guessable or specified; use -f or set EUPS_FLAVOR\n";
      goto CLEAN;
   }
}

#Get the environment variables
%oldenv = %ENV;
@oldkeys = keys %ENV;

# Call either setup or unsetup

if ($select eq "list") {
   if($no_dependencies) {
      warn "Option --just makes no sense with --list and is ignored\n";
   }
   eups_list($comm,$debug,0,$current,$setup,$just_directory,$just_tablefile);
} else {
   if($current) {
      warn "Option --current is always assumed and may be omitted\n";
   }
   if($setup) {
      print STDERR "Option --setup only makes sense with --list\n";
      goto CLEAN;
   }
   
   if ($select eq "setup") {
      $retval = eups_setup($comm, $tmpfile, $no_dependencies, $debug, 0);
      if ($retval < 0) {
	 eups_unsetup($comm, $tmpfile, $no_dependencies, $debug, 1);
	 print STDERR "FATAL ERROR: setup failed\n";
	 goto CLEAN;
      }
   } elsif ($select eq "unsetup") {
      $retval = eups_unsetup($comm, $tmpfile, $no_dependencies, $debug, 0);
      if ($retval < 0) {
	 if ($debug >= 0) {
	    print STDERR "FATAL ERROR: unsetup$comm failed\n";
	 }
	 goto CLEAN;
      }
   } else {
      print STDERR "ERROR: Unknown command \"$select\" to eups_setup\n";
      goto CLEAN;
   }
}

#Check to see and update the environment 

@newkeys = keys %ENV;

for ($i=0;$i<@oldkeys;$i++) {
# Is the variable still set?
    if (!($ENV{$oldkeys[$i]})) {
	unsete($oldkeys[$i]);
	next;
    } 
    $val = $ENV{$oldkeys[$i]};
    $oval = $oldenv{$oldkeys[$i]};
    if (!($val eq $oval)) {
	sete($oldkeys[$i],$val);
    }
}

for ($i = 0; $i<@newkeys; $i++) {
    if (!($oldenv{$newkeys[$i]})) {
	sete($newkeys[$i],$ENV{$newkeys[$i]});
    }
}

if ($debug > 3) {
   warn "Not deleting $fn\n";
} else {
   # Self destruct file
   CLEAN:			# n.b. we can get here without the goto.
   print $tmpfile "\\rm -f $fn\n";
   close $tmpfile;
}

print "$fn\n";

exit;

###############################################################################

sub myexit
{
   my($exit) = @_;
   print "/dev/null\n";
   exit $exit;
}

###############################################################################
#
# Print Help message
#
sub usage
{
   warn <<"EOT";
EUPS : A Unix Versioning System
CVS Version : $Name: not supported by cvs2svn $

Usage: setup [options] [product [version]]
EOT
    eups_show_options($opts);
}
