\documentclass{article}
\ExecuteOptions{dvips,color}
%
\newcommand{\XXX}[1]{\textbf{XXX} #1}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\eups}{\code{ExtUPS}}

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\begin{document}
\title{\eups{} --- a Tool to Manage Software Dependencies}
\author{Nikhil Padmanabhan and Robert Lupton}

\maketitle

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\section{Introduction}

Complex software systems are generally built from a hierarchy of
components, and in general all of these systems are in a state of
flux.  In order to bring order out of chaos, we need to be able to:
\begin{itemize}
  \item Organize the set of components, allowing for their natural
    hierarchy.

  \item
    Select which versions of components should be used, ensuring
    that a consistent set are chosen

  \item
    Configure the environment (\code{PATH}; environment variables)
    for each component.

  \item
    Provide a way to identify a chosen set of components

  \item
    In addition, we would like to be able to install libraries that support
    these versions, and to do so on a number of different platforms.
\end{itemize}

We assume that the task of actually managing individual components
(e.g. tracking code versions) is being handled with some other system,
such as \texttt{cvs} or \texttt{svn}.

\section{The \code{setup} command}

\eups
\footnote{%
  The name comes from \code{UPS} (\code{Unix Product Support}), a
  tool written at Fermi National Accelerator Laboratory, FNAL. \eups{}
  is basically a reimplementation in perl of those parts of \code{UPS}
  that we have found especially valuable.}
achieves all of these goals. A component (refered to as a `product')
may be used after it has been \code{setup}, and these products may
in turn setup other products. When setting up a product, a user
may specify a version, or accept the current default. These setup versions
may either be in a user's file space (e.g. a cvs version), or copies
that have been \code{declare}d to the system; these declarations are
aware of the user's computer architecture (referred to as a `flavor').

The organisation is via `table' files
associated with each component, for example the table file
for a product named \code{photo} reads:
\begin{verbatim}
       setupRequired("astrotools")
       envSet(PHOTO_STARTUP, ${PRODUCT_DIR}/etc/photoStartup.tcl)
       envAppend(PATH, ${PRODUCT_DIR}/bin)
\end{verbatim}

When we attempt to \code{setup} the product \code{photo}, this
table file leads to the following actions:
\begin{description}
\item
  The environment variable \code{PHOTO\_DIR} is automatically set to 
  the root of the directory tree for product \code{photo} (how this
  is determined is described in the next section)
\item
  \code{setupRequired} states that when you \code{setup} this product, you
  should also \code{setup} a product called \code{astrotools}.
  The table file for \code{astrotools} can
  (and in fact does) itself \code{setup} further products.  We say that
  \code{photo} \emph{depends} on \code{astrotools}.
\item
  \code{envSet} sets an extra environment variable; here \code{\$\{PRODUCT\_DIR\}}
  refers to the root of this product's tree (i.e. to \code{PHOTO\_DIR} as set above)
\item
  \code{envAppend} appends
  the directory \code{\$\{PRODUCT\_DIR\}/bin} to the current path (there
  is also a \code{envPrepend} directive).
\end{description}

So far we have achieved the first of the goals listed in the introduction,
describing a hierarchy.  The next section describes how to maintain
multiple versions.

\section{Declaring Products and Versions}

Whence came \code{PHOTO\_DIR} in the example? From a command of the form
\begin{verbatim}
eups_declare photo v5_4_25 -f Darwin -r /u/products/Darwin/photo/v5_4_25
\end{verbatim}

This command updates the \eups{} `database' (in reality a set of files);
this `database' is then `queried' by the \code{setup} command. In
the \code{declare} command,
\begin{itemize}
  \item
    \code{photo} is the name of the product

  \item
    \code{v5\_4\_25} specifies the version number (by convention this
    is a cvs tag)

  \item
    \code{-f Darwin} specifies the flavor (i.e. my computer's hardware and
    operating system)

  \item
    \code{-r /u/products/Darwin/photo/v5\_4\_25} is the directory where
    the specified version can be found. The name is purely conventional,
    but the convention is pretty transparent.

  \item
    This directory is typically created by an \code{install} target
    in a Makefile, but it could simply be your current working
    copy:
\begin{verbatim}
       declare photo cvs -f Darwin -r ~/photo
\end{verbatim}
\end{itemize}

If I now say \code{setup photo v5\_4\_25}, \eups{} will look for
a table file in the directory \code{/u/products/Darwin/photo/v5\_4\_25/ups},
and obey whatever instructions it finds there.  For example,
I will find that
\code{PHOTO\_DIR} is set to \code{/u/products/Darwin/photo/v5\_4\_25}. If,
in the \code{declare} command I'd also specified \code{-c} (for
`current'), then version \code{v5\_4\_25} of \code{photo} would
have become the default, and I could have simply said \code{setup photo}.

You will remember that \code{photo}'s table file simply requested
that \code{astrotools} be setup, but it could have specified a version:
\begin{verbatim}
setupRequired("astrotools v4_10_1")
\end{verbatim}
The table file being used is the one in the \emph{installed} directory,
and the \code{make install} command was free (and indeed encouraged) to
rewrite the table file to specify explicit version numbers.

We have now achieved all of our five goals (although we have not
yet described how to make use of our success): I have defined
a version \code{v5\_4\_25} of a product \code{photo}, which is
to be found in a given directory for a given architecture,
and specified how its environment should be Furthermore,
this version depends on a specific version (\code{v4\_10\_1}) of
\code{astrotools}, and so on. By convention, each of these version
numbers corresponds to a cvs tag in some repository, so I am
able to recover the complete set of releases used to build and
run this version of \code{photo} by examining the \eups{} database.

\section{How do I Actually Use this System to Manage Code?}

The \code{setup} command set a number of environment variables,
such as \code{PHOTO\_DIR} and \code{ASTROTOOLS\_DIR}. These can
be used in Makefiles, e.g.
\begin{verbatim}
CFLAGS = -g $(INCS)
INCS = -I$(ASTROTOOLS_DIR)/include \
       -I$(PHOTO_DIR)/include \
       ...
LIBS =   -L$(ASTROTOOLS_DIR)/lib -lastrom \
         -L$(PHOTO_DIR)/lib -lphoto -lmeasureObj \
         ...
\end{verbatim}

The next section discusses a strategy for managing include files
and libraries using configure and make.

\section{\eups{} and autoconf/configure}

If you're a user, you don't need to understand this section. If
you're creating new products, you may need to.

The \eups{} distribution includes a set of autoconf macros
in the file \texttt{etc/ac\_eups.m4}. Once you've arranged for
autoconf to know about his file,\footnote{e.g. by copying the
  file into your top level directory} you can write a
\texttt{configure.ac} file that looks something like
\begin{quote}
\obeylines\tt\small\parskip=0pt
AC\_INIT([myProduct], [X.Y], [rhl@astro.princeton.edu])
UPS\_DEFINE\_ROOT(\${Name}: v2\_4 \$)
AC\_PROG\_CC(cc)
UPS\_WITH\_CONFIGURE([gsl])
UPS\_WITHOUT\_CONFIGURE([fftw], [fftw3.h], -lfftw3f, [fftw3f,fftwf\_plan\_dft\_2d])
AC\_CONFIG\_FILES([etc/Makefile.global])
AC\_OUTPUT
\end{quote}

Once you've generated a configure file (i.e. typed \texttt{autoconf})%
\footnote{You'll check the resulting configure file in, so users won't
  need to have autoconf on their machines}
you can say\hfil\break
\texttt{setup gsl}\hfil\break
\texttt{./configure --with-ups=/u/act/products --with-flavor=Linux64}\hfil\break
\texttt{make}\hfil\break
\texttt{make install}\hfil\break
\texttt{make declare}\hfil\break
\texttt{setup myProduct v2\_4}\hfil\break

How did your \texttt{configure.ac} file achieve this magic?

\begin{itemize}
  \item{\texttt{AC\_INIT}

    This is a standard autoconf line, but with an invalid version name (\texttt{X.Y}).

  \item{\texttt{AC\_DEFINE\_ROOT}}

    Define the \texttt{configure} options \texttt{--with-ups=dir}} and \texttt{--with-flavor=XXX}.
    The version comes from the \texttt{\${Name}: v2\_4 \$} --- if the \texttt{v2\_4} were
    absent the value \texttt{cvs} would have been used instead.

  \item\texttt{AC\_PROG\_CC(cc)}

    Find the C compiler    

  \item\texttt{UPS\_WITH\_CONFIGURE([gsl])}

    Tell configure that we need the product \texttt{gsl}, and that it
    comes with a pkg-config script.\footnote{%
      I.e. a script \texttt{gsl-config} which accepts arguments \texttt{--cflags}
      and \texttt{--libs} to print out the options that you should pass to the
      compiler and linker to use the \texttt{gsl} libraries. For example,
      \texttt{--libs} $\rightarrow$ \texttt{-I/usr/local/include} and
      \texttt{--cflags} $\rightarrow$ \texttt{-L/usr/local/lib -lgsl -lgslcblas -lm}
      }
    In this case, it came from ups,
    but the macro also supports \texttt{--with-gsl=DIR}; there are
    other possibilies (see the reference manual,
    Sec. \ref{autoconfReference}).  If all goes well the macro macro sets (in the
    case of \texttt{gsl}) the variables \texttt{GSL\_CFLAGS} and \texttt{GSL\_LIBS}.

  \item\texttt{UPS\_WITHOUT\_CONFIGURE([fftw], [fftw3.h], -lfftw3f, [fftw3f,fftwf\_plan\_dft\_2d])}

    This macro is similar to \texttt{UPS\_WITH\_CONFIGURE}, and sets
    \texttt{FFTW\_CFLAGS} and \texttt{FFTW\_LIBS}, armed with knowledge of
    \eups{} and  \texttt{--with-fftw=DIR}.

    The difference is that this time configure has to probe the system
    to find the include files and libraries.  More specifically, it
    checks that it can find \texttt{fftw3.h} and that \texttt{-lfftw3f} provides the symbol
    \texttt{fftwf\_plan\_dft\_2d}.
    
  \item\texttt{AC\_CONFIG\_FILES}
  \item\texttt{AC\_OUTPUT}

    The standard autoconf macro to interpolate derived values
    into \texttt{Makefile.global}.  What does this mean?
    \XXX{Describe Makefile.global.in}
\end{itemize}


\subsection{A Strategy for using autoconf and \eups{} to Manage Layered Products}


A more complete example is:

\begin{quote}
    \obeylines\tt\small\parskip=0pt
AC\_INIT([myProduct], [X.Y], [rhl@astro.princeton.edu])
\vspace{5pt}
dnl --------- UPS directories and how to install --------------------------
\vspace{5pt}
UPS\_DEFINE\_ROOT(\${Name}:  \$)
UPS\_INSTALL\_DIRS   
\vspace{5pt}

dnl --------- Build environment -------------------------------------------

AC\_PROG\_CC(cc)
AC\_PROG\_RANLIB

dnl --------- Products from UPS -------------------------------------------
dnl (remember to update etc/Makefile.global if you add a new product)
\vspace{5pt}
UPS\_WITH\_CONFIGURE([gsl])
UPS\_WITH\_CONFIGURE([pslib])
\vspace{5pt}
UPS\_WITHOUT\_CONFIGURE([cfitsio], [fitsio.h],
                        -lcfitsio, [cfitsio,ffopen])
UPS\_WITHOUT\_CONFIGURE([fftw],    [fftw3.h],
                        -lfftw3f,  [fftw3f,fftwf\_plan\_dft\_2d])
UPS\_WITHOUT\_CONFIGURE([wcslib],  [wcslib/wcslib.h],
                        -lwcs,     [wcs,wcsini])
\vspace{5pt}
AC\_CONFIG\_FILES([etc/makedefs etc/builddefs etc/installdefs])
AC\_CONFIG\_FILES([bin/eups\_import], [chmod 755 bin/eups\_import])
\vspace{5pt}
AC\_OUTPUT
\end{quote}

\appendix

\section{\eups Reference Manual}

\subsection{\eups{} commands}

\begin{itemize}

%------------------------------------------------------------------------------

\item \texttt{eups\_declare}
\begin{verbatim}
Usage:
   eups_declare [options] product version
Options:
        -h, --help      Print this help message
        -c, --current   Declare this product current
        -F, --force     Force requested behaviour (e.g. redeclare a product)
        -f, --flavor    Use this flavor (default: $EUPS_FLAVOR)
        -m              Use this table file (may be "none") (default: product.table)
        -r, --root      Location of product being declared
        -V, --version   Print version number and exit
        -v, --verbose   Be chattier (repeat for even more chat)
        -Z, --database  Use this products prefix (default: $PROD_DIR_PREFIX)
        -z              Use this products database (default: $PRODUCTS)
\end{verbatim}

Declares \texttt{version} of \texttt{product} into the database defined by \texttt{\$PRODUCTS}.
The product root directory is where the product has been installed, and can either
be an absolute pathname or specified relative to \texttt{\$PROD\_DIR\_PREFIX}.

The flavor is usually determined from the
environment variable \texttt{\$EUPS\_FLAVOR}, but \texttt{-f}
overrides this. The database used is defined by the environment
variable \texttt{PRODUCTS} (or the \texttt{-z} or \texttt{-Z} option).
The \texttt{-m} option specifies the table
file to be used (either in the database, or in the ups directory of the product).

If you omit both \texttt{product} and \texttt{version}, but provide \texttt{-r dir},
the product and version will be guessed from the last two parts of the directory
name (e.g. \texttt{-r /home/eups/products/Linux/xpa/v2\_1\_6} will be taken to be
declaring version \texttt{v2\_1\_6} of product \texttt{xpa}).

If you specify \texttt{-c} then it leaves the currently declared version alone, and
only updates the current.chain.

%------------------------------------------------------------------------------

  \item \texttt{eups\_undeclare}
\begin{verbatim}
Usage:
   eups_undeclare [options] product version
Options:
        -h, --help      Print this help message
        -f, --flavor    Use this flavor (default: $EUPS_FLAVOR)
        -V, --version   Print version number and exit
        -v, --verbose   Be chattier (repeat for even more chat)
        -Z, --database  Use this products prefix (default: $PROD_DIR_PREFIX)
        -z              Use this products database (default: $PRODUCTS)
\end{verbatim}
  
Undeclares \texttt{version} of \texttt{product} from the
database. Also removes any declarations of this version from
\texttt{current.chain}. The flavor is usually determined from the
environment variable \texttt{\$EUPS\_FLAVOR}, but \texttt{-f}
overrides this. The database used is defined by the environment
variable \texttt{PRODUCTS} (or the \texttt{-z} or \texttt{-Z} option).

%------------------------------------------------------------------------------

\item \texttt{setup}
\begin{verbatim}
Usage:
   setup [options] [product [version]]
Options:
        -h, --help      Print this help message
        -c, --current   Show current version
        -f, --flavor    Use this flavor (default: $EUPS_FLAVOR)
        -l, --list      List available versions (-v => include root directories)
        -n              Don't actually do anything
        -q, --quiet     Be extra quiet (the opposite of -v)
        -r, --root      Location of product being declared
        -s, --setup     Show which version is setup
        -V, --version   Print version number and exit
        -v, --verbose   Be chattier (repeat for even more chat)
        -Z, --database  Use this products prefix (default: $PROD_DIR_PREFIX)
        -z              Use this products database (default: $PRODUCTS)
\end{verbatim}

This is the workhorse routine. It sets up \texttt{version} of \texttt{product}.

\textbf{Important}: Since the commands to set environment variables differ across shells,
it is essential that \texttt{\$SHELL} reflects the current shell.

Options \texttt{--current} and \texttt{--setup} are only relevant with \texttt{--list}.

(N.b. setup is really an alias or shell function that runs the command\hfil\break
\texttt{source `eups\_setup [options] "setup" product [version]`}\hfil\break
\texttt{eups\_setup} writes a shell script that is then sourced into the
current shell.
)

With the \texttt{--list} option, \texttt{setup} can be used to list the available
products; for example \texttt{setup --list --current} will list all products that
are declared current.

%------------------------------------------------------------------------------

\item \texttt{unsetup}
\begin{verbatim}
Usage:
   unsetup [options] product
Options:
(same as setup)
\end{verbatim}
  
All the notes under \texttt{setup} apply to
\texttt{unsetup}. Unsetting up a product relies on the environment
variable \texttt{\$SETUP\_$<$product$>$}, so it fails if the variable
isn't set.

\end{itemize}

\subsection{Environment Variables}

Required variables -

\begin{itemize}
  \item \texttt{SHELL}
    This must be set to the shell running. This is true in general, unless
    you run a shell script, or change your shell.

  \item \texttt{EUPS\_DIR}
    Where EUPS\_DIR is installed.

  \item \texttt{PROD\_DIR\_PREFIX}
    The root directory under which all products are installed.

  \item \texttt{PRODUCTS}
    The path to the UPS database.
\end{itemize}

Optional Variables -

\begin{itemize}
  \item \texttt{EUPS\_FLAVOR}
    Set to the default flavor.

  \item \texttt{EUPS\_DEBUG}
    This sets the verbosity; equal to the difference beteween the number of \texttt{-v}s
    and \texttt{-q}s.

    If you are confused by some error, or simply nosy, try adding a \texttt{-v}.
\end{itemize}

\subsection{The Database}

\subsubsection{\eups{} Files}

This section briefly describes the structure of the UPS database. The UPS database
consists of a directory \$PRODUCTS, with a subdirectory for each declared product.
Each of these product directories contain a series of product definitions, specified
by three types of files:

\begin{itemize}
  \item current.chain

    There is only one (if any) of these per directory.  The
    current.chain file specifies the current version for a given
    flavor, and is what is used as the default if the version is not
    specified.

  \item Version files

    There is one of these for every declared version of the product,
    named \texttt{<version>.version}. The file specifies basic information
    about the version of the product, including where it is installed.

  \item Table files

    These specify the dependencies of the product. The default name
    for these is \texttt{<version>.table} although a specific name can be specified in the
    version file.

    Table files use a series of commands to specify the dependencies. These are
    discussed in the next subsection.

    NOTE: See Section 5 for a note on the search algorithm that EUPS uses for 
    locating table files.
\end{itemize}

\subsubsection{\eups{} commands}

The following table commands are supported by \eups{}: ($<$NAME$>$ either specifies an
alias or an environment variable - clear from the context.)

\begin{itemize}
   \item \texttt{addAlias($<$NAME$>$,$<$Value$>$)}
     Defines a function or an alias.
    
   \item \texttt{envAppend($<$NAME$>$,$<$Value$>$,[$<$delimiter$>$])}
     Appends $<$Value$>$ to $<$NAME$>$. The default delimiter is `:'.
     
   \item \texttt{envPrepend($<$NAME$>$,$<$Value$>$,[$<$delimiter$>$])}
     Similar to envAppend
     
   \item \texttt{envSet($<$NAME$>$,$<$Value$>$)}
     Set $<$NAME$>$ to $<$Value$>$
     
   \item \texttt{setupRequired($<$args$>$)}
     Run setup with arguments args. Fail if unable to setup.
     
   \item \texttt{setupOptional($<$args$>$)}
     Same as setupRequired except that it does not fail if unable to setup.
\end{itemize}

There are also \texttt{envRemove} and \texttt{envUnset()} commands, which
are the inverse of \texttt{env\{Ap,Pre\}pend} and \texttt{envSet()}; I have
never used either.     

\subsubsection{Obselete table commands}

\begin{itemize}
   \item \texttt{pathAppend}, \texttt{pathPrepend}, \texttt{pathRemove}, \texttt{pathSet}
     Aliases for the \texttt{env} commands.
     
   \item \texttt{prodDir()}
     Sets \texttt{$<$PRODUCT$>$\_DIR} to the directory where the product is installed;
     this directive is ignored as \texttt{$<$PRODUCT$>$\_DIR} is automatically set for you.
     
   \item \texttt{setupEnv()}
     Sets \texttt{SETUP\_$<$PRODUCT$>$} so that product can be unsetup.
     this directive is ignored as \texttt{$<$PRODUCT$>$\_DIR} is automatically set for you.
\end{itemize}
        
\subsubsection{Variables}

The values to these UPS commands can be variables. All environment
variables can be used as \${$<$ENV\_VARIABLE$>$}. In addition, the following special
variables are defined;

\begin{itemize}
  \item \texttt{\${PRODUCTS}}
    The database
    
  \item \texttt{\${PRODUCT\_DIR}}
    Where the product is installed.
    
  \item \texttt{\${PRODUCT\_FLAVOR}}
    The product flavor.
    
  \item \texttt{\${PRODUCT\_NAME}}
    The product name
    
  \item \texttt{\${PRODUCT\_VERSION}}
    The product version
    
  \item \texttt{\${UPS\_DIR}}
    The ups directory of the product (distinct from the directory
    in \texttt{\$PRODUCTS} - this is often where the table file will be stored).
\end{itemize}

\subsection{\eups{} autoconf commands}
\label{autoconfReference}

\XXX{Finish me}

\begin{itemize}
  \item{\texttt{AC\_INIT(product, version, ...}}
    This is a standard autoconf line, but with an invalid version name (\texttt{X.Y}).

  \item{\texttt{AC\_DEFINE\_ROOT(version [, flavor])}}
    Define the \texttt{configure} options
    \begin{itemize}
      \item{\texttt{--with-ups=dir}}
        Specify the value of \texttt{PROD\_DIR\_PREFIX}
        (default: \texttt{\$prefix/share}).
        \XXX{This is scheduled to be renamed to \texttt{UPS\_ROOT}}
      \item{\texttt{--with-flavor=XXX}}
        Set the value of \texttt{EUPS\_FLAVOR}
        (default: flavor, or, failing that, the value of uname).
    \end{itemize}
\end{itemize}

The conventional files are:
\begin{itemize}
   \item{etc/builddefs}
     Supports building on this platform. E.g.
\begin{verbatim}
CC = cc -std=c99
CFLAGS = -g -Wall
RANLIB = ranlib
\end{verbatim}
  
   \item{etc/installdefs}
     Supports the \texttt{make install} and \texttt{make declare} targets.
  
   \item{etc/makedefs}
     Supports building and linking products (GSL in this case). After
     expansion, the file will look like:
\begin{verbatim}
GSL_CFLAGS = -I$(GSL_DIR)/include
GSL_LIBS = -L$(GSL_DIR)/lib -lgsl -lgslcblas -lm
\end{verbatim}
\end{itemize}
  
\section{Installing \eups{}}
  
  To install you need first to generate a Makefile:
\begin{verbatim}
./configure && make install
\end{verbatim}

You can say \texttt{make show} to show you where things are
going to be installed:
\begin{verbatim}
$ make show
You will be installing ups in $EUPS_DIR        = /usr/local/share/eups
Ups will look for products in $PROD_DIR_PREFIX = /usr/local/share
The products database will be $PRODUCTS        = /usr/local/share/ups_db
\end{verbatim}

You can control where files are put with the following configure options:
\begin{verbatim}
--prefix=PREFIX         install architecture-independent files in PREFIX
                        [default: /usr/local]
--with-ups=DIR          Use DIR as root for installed products
--with-ups_db=DIR       Use DIR as the UPS database directory
--with-eups_dir=DIR     Install eups into DIR/{bin,doc}
\end{verbatim}
The difference between \texttt{--prefix} and \texttt{--with-ups}
is that the former appends \texttt{/share} to the specified directory, to
be consistent with the standard default value, \texttt{/usr/local}.
  
As an alternative to
\begin{verbatim}
./configure --prefix=/foo/bar
...
make install
\end{verbatim}
you can say
\begin{verbatim}
make install prefix=/foo/bar
\end{verbatim}
\texttt{PROD\_DIR\_PREFIX=...} also works as an alternative to \texttt{--with-ups=...};
note upper case.
\end{document}
