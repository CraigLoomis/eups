\documentclass{article}
\ExecuteOptions{dvips,color}
\usepackage{fullpage}
%
\newcommand{\XXX}[1]{\textbf{XXX} #1}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\eups}{\code{ExtUPS}}
\newcommand{\pacman}{\code{pacman}}
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\begin{document}
\title{\eups{} --- a Tool to Manage Software Dependencies}
\author{Nikhil Padmanabhan, Robert Lupton, and Craig Loomis}

\maketitle

\tableofcontents
\newpage

%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

\section{Introduction}

Complex software systems are generally built from a hierarchy of
components, and in general all of these systems are in a state of
flux.  In order to bring order out of chaos, we need to be able to:
\begin{itemize}
  \item Organize the set of components, allowing for their natural
    hierarchy.

  \item
    Select which versions of components should be used, ensuring
    that a consistent set are chosen

  \item
    Configure the environment (\code{PATH}; environment variables)
    for each component.

  \item
    Provide a way to identify a chosen set of components

  \item
    In addition, we would like to be able to install libraries that support
    these versions, and to do so on a number of different platforms.
\end{itemize}

We assume that the task of actually managing individual components
(e.g. tracking code versions) is being handled with some other system,
such as \code{cvs} or \code{svn}.

\section{The \code{setup} command}

\eups
\footnote{%
  The name comes from \code{UPS} (\code{Unix Product Support}), a
  tool written at Fermi National Accelerator Laboratory, FNAL. \eups{}
  is basically a reimplementation in perl of those parts of \code{UPS}
  that we have found especially valuable.}
achieves all of these goals. A component (refered to as a `product')
may be used after it has been \code{setup}, and these products may
in turn setup other products. When setting up a product, a user
may specify a version, or accept the current default. These setup versions
may either be in a user's file space (e.g. a cvs version), or copies
that have been \code{declare}d to the system; these declarations are
aware of the user's computer architecture (referred to as a `flavor').

The organisation is via `table' files
associated with each component, for example the table file
for a product named \code{photo} reads:
\begin{verbatim}
       setupRequired("astrotools")
       envSet(PHOTO_STARTUP, ${PRODUCT_DIR}/etc/photoStartup.tcl)
       envAppend(PATH, ${PRODUCT_DIR}/bin)
\end{verbatim}

When we attempt to \code{setup} the product \code{photo}, this
table file leads to the following actions:
\begin{description}
\item
  The environment variable \code{PHOTO\_DIR} is automatically set to 
  the root of the directory tree for product \code{photo} (how this
  is determined is described in the next section)
\item
  \code{setupRequired} states that when you \code{setup} this product, you
  should also \code{setup} a product called \code{astrotools}.
  The table file for \code{astrotools} can
  (and in fact does) itself \code{setup} further products.  We say that
  \code{photo} \emph{depends} on \code{astrotools}.
\item
  \code{envSet} sets an extra environment variable; here \code{\$\{PRODUCT\_DIR\}}
  refers to the root of this product's tree (i.e. to \code{PHOTO\_DIR} as set above)
\item
  \code{envAppend} appends
  the directory \code{\$\{PRODUCT\_DIR\}/bin} to the current path (there
  is also a \code{envPrepend} directive).
\end{description}

So far we have achieved the first of the goals listed in the introduction,
describing a hierarchy.  The next section describes how to maintain
multiple versions.

\section{Installing \eups}

If you want to play with \eups{} you may want to install a copy.

You can check out a copy from \code{cvs} if you have access to
Princeton machines:
\begin{verbatim}
  cvs -d jeeves.astro.princeton.edu:/usr/local/cvsroot co eups
\end{verbatim}

Alternatively, grab the tarball
\begin{verbatim}
http://www.astro.princeton.edu/~act/packages/eups.tar.gz
\end{verbatim}

Then unpack it, configure, and install.  E.g.
\begin{verbatim}
zcat eups.tar.gz | tar -xf -
cd eups
./configure --with-eups=/u/act/products
make show
make install
\end{verbatim}

The \code{make install} command will tell you to source a file
with a name such as
\begin{verbatim}
/u/act/products/eups/bin/setups.sh
\end{verbatim}
which will make \eups{} commands available to you; csh users should
use \code{setups.csh}.  You'll probably want to add this line to your
shell startup file (.bashrc or .tcshrc).

\section{Declaring Products and Versions}

Whence came \code{PHOTO\_DIR} in the example? From a command of the form
\footnote{Actually, a simple \code{eups\_declare photo v5\_4\_25} would suffice}
\begin{verbatim}
eups_declare photo v5_4_25 -f Darwin -r /u/products/Darwin/photo/v5_4_25
\end{verbatim}

This command updates the \eups{} `database' (in reality a set of files);
this `database' is then `queried' by the \code{setup} command. In
the \code{declare} command,
\begin{itemize}
  \item
    \code{photo} is the name of the product

  \item
    \code{v5\_4\_25} specifies the version number (by convention this
    is a cvs tag)

  \item
    \code{-f Darwin} specifies the flavor (i.e. my computer's hardware and
    operating system)

  \item
    \code{-r /u/products/Darwin/photo/v5\_4\_25} is the directory where
    the specified version can be found. The name is purely conventional,
    but the convention is pretty transparent.

  \item
    This directory is typically created by an \code{install} target
    in a Makefile, but it could simply be your current working
    copy:
\begin{verbatim}
       declare photo cvs -f Darwin -r ~/photo
\end{verbatim}
\end{itemize}

If I now say \code{setup photo v5\_4\_25}, \eups{} will look for
a table file in the directory\hfil\break \code{/u/products/Darwin/photo/v5\_4\_25/ups},
and obey whatever instructions it finds there.  For example,
I will find that
\code{PHOTO\_DIR} is set to \code{/u/products/Darwin/photo/v5\_4\_25}. If,
in the \code{declare} command I'd also specified \code{-c} (for
`current'), then version \code{v5\_4\_25} of \code{photo} would
have become the default, and I could have simply said \code{setup photo}.

You will remember that \code{photo}'s table file simply requested
that \code{astrotools} be setup, but it could have specified a version:
\begin{verbatim}
setupRequired("astrotools v4_10_1")
\end{verbatim}
The table file being used is the one in the \emph{installed} directory,
and the \code{make install} command was free (and indeed encouraged) to
rewrite the table file to specify explicit version numbers.

We have now achieved all of our five goals (although we have not
yet described how to make use of our success): I have defined
a version \code{v5\_4\_25} of a product \code{photo}, which is
to be found in a given directory for a given architecture,
and specified how its environment should be Furthermore,
this version depends on a specific version (\code{v4\_10\_1}) of
\code{astrotools}, and so on. By convention, each of these version
numbers corresponds to a cvs tag in some repository, so I am
able to recover the complete set of releases used to build and
run this version of \code{photo} by examining the \eups{} database.

\section{How do I Actually Use this System to Manage Code?}

All that the \code{setup} command did was to set or append to a number of environment variables,
such as \code{PHOTO\_DIR}, \code{ASTROTOOLS\_DIR}, and (often) \code{LD\_LIBRARY\_PATH}.
These can be used in Makefiles, e.g.
\begin{verbatim}
CFLAGS = -g $(INCS)
INCS = -I$(ASTROTOOLS_DIR)/include \
       -I$(PHOTO_DIR)/include \
       ...
LIBS =   -L$(ASTROTOOLS_DIR)/lib -lastrom \
         -L$(PHOTO_DIR)/lib -lphoto -lmeasureObj \
         ...
\end{verbatim} %$

The next section discusses a strategy for managing include files
and libraries using configure and make.

\section{\eups{} and autoconf/configure}

If you're a user, you don't need to understand this section. If
you're creating new products, you may need to.

The \eups{} distribution includes a set of autoconf macros
in the file \file{etc/ac\_eups.m4}. Once you've arranged for
autoconf to know about this file,\footnote{e.g. by copying the
  file into your top level directory} you can write a
\file{configure.ac} file that looks something like
\begin{quote}
\obeylines\tt\small\parskip=0pt
AC\_INIT([myProduct], [X.Y], [rhl@astro.princeton.edu])
UPS\_DEFINE\_ROOT(\${Name}: v2\_4 \$)
AC\_PROG\_CC(cc)
UPS\_WITH\_CONFIGURE([gsl])
UPS\_WITHOUT\_CONFIGURE([fftw3], [fftw3.h], -lfftw3f, [fftw3f,fftwf\_plan\_dft\_2d])
AC\_CONFIG\_FILES([etc/Makefile.global])
AC\_OUTPUT
\end{quote}

Once you've generated a configure file (i.e. typed \code{autoconf})%
\footnote{You'll check the resulting configure file in, so users won't
  need to have autoconf on their machines}
you can say\hfil\break
\code{cd \$HOME/myProduct}\hfil\break
\code{setup gsl; setup fftw3}\hfil\break
\code{./configure --with-eups=/u/act/products --with-flavor=Linux64}\hfil\break
\code{make}\hfil\break
\code{make install}\hfil\break
\code{make declare}\hfil\break
\code{setup myProduct v2\_4}\hfil\break

You might wonder how you were supposed to know that you had to type
\code{setup gsl} and \code{setup fftw3} in order to build
\code{myProduct}. The answer, is: ``It depends''.  If you're
\code{myProduct}'s loving author, you knew that you needed
\code{gsl} as you included e.g. \code{gsl/gsl\_rng.h} in your
source. If you're not the author, then \code{myProduct} presumably
includes a properly written table file (probably called
\code{myProduct/ups/myProduct.table}) which knows about
\code{gsl} and \code{fftw3}:
\begin{verbatim}
setupRequired("fftw3")
setupRequired("gsl")
\end{verbatim}
in this case what you \textit{really} typed was:\hfil\break
\code{setup --root \$HOME/myProduct myProduct}\hfil\break
which setup \code{gsl} and \code{fftw3} for you:
\begin{verbatim}
Setting up:      fftw3               Flavor: Linux      Version: v3_0_1
Setting up:      gsl                 Flavor: Linux      Version: v1_8
\end{verbatim}

The \code{make declare} command told \eups{} about your newly built
product; the \code{setup myProduct v2\_4} command told the system
that you wanted to use it.

How did your \file{configure.ac} file achieve this magic?

\begin{itemize}
  \item{\code{AC\_INIT}}

    This is a standard autoconf line, but with an invalid version name (\code{X.Y}).

  \item{\code{AC\_DEFINE\_ROOT}}

    Define the \code{configure} options \code{--with-eups=path},
    \code{--with-eups-db=DB}, and \code{--with-flavor=XXX}. The
    version comes from the \code{\${Name}: v2\_4 \$} --- if the
    \code{v2\_4} were absent the value \code{cvs} would have been used
    instead.

  \item\code{AC\_PROG\_CC(cc)}

    Find the C compiler    

  \item\code{UPS\_WITH\_CONFIGURE([gsl])}

    Tell configure that we need the product \code{gsl}, and that it
    comes with a pkg-config script.\footnote{%
      I.e. a script \code{gsl-config} which accepts arguments \code{--cflags}
      and \code{--libs} to print out the options that you should pass to the
      compiler and linker to use the \code{gsl} libraries. For example,
      \code{--libs} prints \code{-I/usr/local/include} and
      \code{--cflags} prints \code{-L/usr/local/lib -lgsl -lgslcblas -lm}
      }
    In this case, it came from ups,
    but the macro also supports \code{--with-gsl=DIR}; there are
    other possibilies (see the reference manual,
    Sec. \ref{autoconfReference}).  If all goes well the macro macro sets (in the
    case of \code{gsl}) the variables \code{GSL\_CFLAGS} and \code{GSL\_LIBS}.

  \item\code{UPS\_WITHOUT\_CONFIGURE([fftw3], [fftw3.h], -lfftw3f, [fftw3f,fftwf\_plan\_dft\_2d])}

    This macro is similar to \code{UPS\_WITH\_CONFIGURE}, and sets
    \code{FFTW\_CFLAGS} and \code{FFTW\_LIBS}, armed with knowledge of
    \eups{} and  \code{--with-fftw3=DIR}.

    The difference is that this time configure has to probe the system
    to find the include files and libraries.  More specifically, it
    checks that it can find \code{fftw3.h} and that \code{-lfftw3f} provides the symbol
    \code{fftwf\_plan\_dft\_2d}.
    
  \item\code{AC\_CONFIG\_FILES}
  \item\code{AC\_OUTPUT}

    The standard autoconf macro to interpolate derived values
    into \file{Makefile.global}.  What does this mean?
    \XXX{Describe Makefile.global.in}
\end{itemize}


\subsection{A Strategy for using autoconf and \eups{} to Manage Layered Products}


A more complete example is:

\begin{quote}
    \obeylines\tt\small\parskip=0pt
AC\_INIT([myProduct], [X.Y], [rhl@astro.princeton.edu])
\vspace{5pt}
dnl --------- UPS directories and how to install --------------------------
\vspace{5pt}
UPS\_DEFINE\_ROOT(\${Name}:  \$)
UPS\_INSTALL\_DIRS   
\vspace{5pt}

dnl --------- Build environment -------------------------------------------

AC\_PROG\_CC(cc)
AC\_PROG\_RANLIB

dnl --------- Products from UPS -------------------------------------------
dnl (remember to update etc/Makefile.global if you add a new product)
\vspace{5pt}
UPS\_WITH\_CONFIGURE([gsl])
UPS\_WITH\_CONFIGURE([pslib])
\vspace{5pt}
UPS\_WITHOUT\_CONFIGURE([cfitsio], [fitsio.h],
                        -lcfitsio, [cfitsio,ffopen])
UPS\_WITHOUT\_CONFIGURE([fftw3],   [fftw3.h],
                        -lfftw3f,  [fftw3f,fftwf\_plan\_dft\_2d])
UPS\_WITHOUT\_CONFIGURE([wcslib],  [wcslib/wcslib.h],
                        -lwcs,     [wcs,wcsini])
\vspace{5pt}
AC\_CONFIG\_FILES([etc/makedefs etc/builddefs etc/installdefs])
AC\_CONFIG\_FILES([bin/eups\_import], [chmod 755 bin/eups\_import])
\vspace{5pt}
AC\_OUTPUT
\end{quote}

\section{Using \eups{} with python}

\eups{} is currently mostly written in perl, but we hope to do a
complete rewrite in python at some point.  At present, there is a
python module that allows access to (most) of \eups's functionality;
missing commands will probably be added as we get around to it.

There's also an option parsing class \code{Getopt} (used by \code{eups\_distrib}) that
offers features not present in python's regular \code{getopt} module.

To use \eups{} from python, you need to \code{import eups};
\code{help(eups)} then reveals:
\begin{verbatim}
CLASSES
    Getopt
    
    class Getopt
     |  Methods defined here:
     |  
     |  __init__(self, options, argv=[''], aliases={}, msg=None)
     |      A class to represent the processed command line arguments.
     |      
     |      options is a dictionary whose keys are is the short name of the option
     |      (and the one that it'll be indexed as), and the value is a tuple; the
     |      first element is a boolean specifying if the option takes a value; the
     |      second (if not None) is a long alias for the option, and the third is
     |      a help string.  E.g.
     |          ["-i", (False, "--install", "Extract and install the specified package")],
     |      
     |      aliases is another dictionary, with values that specify additional long versions
     |      of options; e.g.
     |          ["-i", ["--extract"]],
     |      
     |      Options may be accessed as Getopt.options[], and non-option arguments as Getopt.argv[]
     |      
     |      msg is the help message associated with the command
     |  
     |  has_option(self, opt)
     |      Whas the option "opt" provided
     |  
     |  usage(self)
     |      Print a usage message based on the options list

FUNCTIONS
    current(product='', dbz='', flavor='')
        Return the current version of a product; if product is omitted,
        return a list of (product, version) for all products
    
    database(product, version='current', dbz='', flavor='')
        Return the database for the specified product and version
    
    declare(flavor, dbz, tablefile, products_root, product_dir, product, version,
            declare_current=False, noaction=False)
        Declare a product
    
    dependencies(product, version, dbz='', flavor='')
        Return a product's dependencies in the form of a list of tuples
        (product, version, flavor)
    
    directory(product, version='current', dbz='', flavor='')
        Return the PRODUCT_DIR for the specified product and version
    
    flavor()
        Return the current flavor
    
    isCurrent(product, version, dbz='', flavor='')
        Return True iff the the specified product and version is current
    
    isSetup(product, version, dbz='', flavor='')
        Return True iff the the specified product and version is setup
    
    list(product, version='', dbz='', flavor='')
        Return a list of declared versions of a product; if the
        version is specified, just return the properties of that version.
        The version may be "current" or "setup" to return the current
        or setup version.
        
        The return value for each product is a list of lists:
           [[version, database, directory, isCurrent, isSetup], ...]
        (if only one version matches, the return is a single list; if no versions
        match, you'll get None)
    
    setup(product='', dbz='', flavor='')
        Return the setup version of a product; if product is omitted,
        return a list of (product, version) for all products
    
    table(product, version, flavor='')
        Return the full path of a product's tablefile
    
    version()
        Return eups' current cvs version
\end{verbatim}

\appendix

\section{\eups{} Reference Manual}

\subsection{\eups{} commands}

\begin{itemize}

%------------------------------------------------------------------------------

  \item \code{eups}
\begin{verbatim}
Usage:
        eups [--help|--version] command [options]
Supported commands are:
        declare         Declare a product
        distrib         Install a product from a remote distribution,
                        or create such a distribution 
        expandtable     Insert explicit version tags into a table file
        flavor          Return the current flavor
        list            List some or all products
        path            Print the current eups path	
        pkg-config      Return the options associated with product
        undeclare       Undeclare a product
Use
        eups --help cmd
for help with command "cmd"
\end{verbatim}
  
A consistent front-end to all the other \eups{} commands.  The commands
starting \code{eups\_} will eventually go away, leaving only \code{eups}.

%------------------------------------------------------------------------------

\item \code{eups\_declare}
\begin{verbatim}
Usage:
   eups_declare [options] product version
Options:
        -h, --help      Print this help message
        -c, --current   Declare this version current
        -F, --force     Force requested behaviour, for example
                        to redeclare a product
        -f, --flavor    Use this flavor
                        (default: $EUPS_FLAVOR or `eups_flavor`)
        -M              Import the given file (may be \"-\" for stdin)
                        into the database as the table file
        -m, --table     Use this table file (may be "none")
                        (default: product.table)
        -r, --root      Location of product being declared
        -V, --version   Print eups version number and exit
        -v, --verbose   Be chattier (repeat for even more chat)
        -Z, --database  Use this products prefix
                        (default: $EUPS_PATH)
        -z, --select-db Select the product paths which contain this directory 
                        (default: all)
\end{verbatim}

Declares \code{version} of \code{product} into the database given by \code{\$EUPS\_PATH/ups\_db}.
The product root directory is where the product has been installed, and can either
be an absolute pathname or specified relative to \code{\$EUPS\_PATH}.

The flavor is usually determined by the command \code{\$EUPS\_DIR/bin/eups\_flavor},
but may be set using the
environment variable \code{\$EUPS\_FLAVOR}, or \code{-f} (which has the highest
precedence).  The \code{eups\_flavor} is basically the value of the system \code{uname}
command, but with a little more information where it's important (e.g. Linux boxes
can have flavor \code{Linux} or \code{Linux64}).

The \code{eups\_declare} command has to decide which database in the environment
variable\code{EUPS\_PATH}
to use.  If the product's already declared, use the database it's in (this is usually
only relevant when you're declaring a product current).  Otherwise, if the specified root
lies within a database in \code{EUPS\_PATH}, use that database; as a last resort use
the database that's listed first in \code{EUPS\_PATH}.

The desired database can also be specified
explicitly with the \code{-Z} option (which overrides \code{EUPS\_PATH}), or by using \code{-z}
to specify a path component; e.g.
\code{-Z /home/proj1/eups:/home/proj2/eups -z proj2} would select \code{/home/proj2/eups}.

The \code{-m} option specifies the table
file to be used (either in the database, or in the ups directory of the product).

The \code{-M} option specifies a file which will be copied into the
database as a table file. This lets you avoid putting EUPS data
into products. You can pipe the table file to \code{eups\_declare} by
specifying \code{-} as the filename.

If you omit the \code{-r dir}, \eups{} will attempt to guess it for you based
on your products directory, flavor, product and version; alternatively,
if you omit both \code{product} and \code{version}, but provide \code{-r dir},
the product and version will be guessed from the last two parts of the directory
name (e.g. \code{-r /home/eups/products/Linux/xpa/v2\_1\_6} will be taken to be
declaring version \code{v2\_1\_6} of product \code{xpa}).

You may specify \code{-r none}, in which case you don't have any files; this
is only permitted if you also specify \code{-M} to provide a table file.  This
can be handy if you want an alias; e.g.
\begin{verbatim}
echo "setupRequired(visionWorkbench)" | eups declare -r none -M - vw current
\end{verbatim}
makes \code{vw} an alias for product \code{visionWorkbench}. You can make
an alias for a specific version with e.g.
\begin{verbatim}
setup visionWorkbench 1.0.0
echo "setupRequired(visionWorkbench)" | eups expandtable | \
	eups declare -r none -M - vw 1.0.0
\end{verbatim}


If you want to
know what \code{vw} does, type e.g.
\begin{verbatim}
cat $(eups list vw -m)
\end{verbatim}				%$ for emacs

If you specify \code{-c} then it leaves the currently declared version alone, and
only updates the current.chain.

%------------------------------------------------------------------------------

  \item \code{eups\_distrib}
\begin{verbatim}
Usage:
   eups_distrib [opts] [product [version]]
Options:
   -b, --prefer-flavor       Prefer distributions that are flavor-specific
   -C, --current         Create a list of current versions which -i can use
   -c, --create          Create a package for distribution
   -F, --force           Force requested behaviour (e.g. redeclare a product)
   -f, --flavor    arg   Use this flavor. Default: $EUPS_FLAVOR or `eups_flavor`
   -h, --help            Print this help message
   -i, --install         Extract and install the specified package
                         Alias: --extract
   -j, --nodepend        Just install product, but not its dependencies
   -n, --noaction        Don't actually do anything
   -p, --pacman    arg   Use this pacman cache to install packages
   -r, --root      arg   Location of manifests and tarballs (may be a URL);
                         Default: $EUPS_PKGROOT
   -t, --prefer-tag arg   Prefer distributions that are tagged with this tag
   -V, --version         Print eups version number and exit
   -v, --verbose         Be chattier (repeat for even more chat)
   -Z, --database  arg   Use this products path. Default: $EUPS_PATH
                         Alias: --with-eups
   -z, --select-db arg   Select the product paths which contain this directory.
                         Default: all
\end{verbatim}				% $ for emacs

Handle the distribution of products and their dependencies as `packages'. A
package is a set of tarballs (i.e. gzipped tar archives) or pacman\footnote{%
  See Appendix \ref{pacman}.
}
caches and
a file (ending in \code{.manifest})
listing a product's dependencies, including the names of the proper tarballs/caches. 

Once you've created a package with \code{eups\_distrib --create} you can log on to
another machine and use \code{eups\_distrib --install} to
recreate a working \eups{} installation.  For example:
\begin{verbatim}
eups_distrib --verbose --select-db act --create moby v1_2
eups_distrib --database /u/rhl/ppp --verbose --install \
             --root http://www.astro.princeton.edu/~act/packages moby v1_2
\end{verbatim}
to install \code{moby} into a \file{/u/rhl/ppp} \eups{} database. If you omit
\code{--root} it'll be taken from the environment variable \code{EUPS\_PKGROOT},
if set.

When creating an distribution, tarballs that already present are not recreated
(unless you specify \code{--force}),
so repeating a \code{eups\_distrib --create} command to create a manifest for another
product won't lead to duplication of tarballs.  If you want to use \pacman{},
see App. \ref{pacman}.

When unpacking a distribution with \code{eups\_distrib --install}, products that are
already declared to \eups{} won't be unpacked and re-declared (unless you specify \code{--force}).

If you don't specify a version when installing a distribution with
\code{--install} the current version will be used.  This isn't quite the same
as the version declared current on some machine where the distribution
originated, as a bleeding-edge version acceptable in Princeton may not
be ready for deployment on a mountain top in e.g. Chile. In
consequence, the list of `current' versions is \textit{not}
automatically created or updated by \code{eups\_distrib --create}, but is
only set when you later say \code{eups\_distrib --current}.  If you don't specify
a product, the list will in fact be identical to your local preferences.
Alternatively, you can update a single product's version number (e.g.
\code{eups\_distrib --current moby}) or specify a version (\code{eups\_distrib --current moby v1\_2}).

\textit{N.b.} As presently written, \code{eups\_distrib} assumes that you've
installed all the products into \eups, as opposed to simple declaring them, but
relying on files installed in e.g. \code{/usr/local}; more precisely, it assumes
that all product directories start with a directory listed in \code{EUPS\_PATH}.
This is probably a good idea, as otherwise \code{eups\_distrib} would tar up
all of /usr/local for you.
  
%------------------------------------------------------------------------------

  \item \code{eups\_expandtable}
\begin{verbatim}
Usage: eups_expandtable [options] file.table [directory]
Options are
    -h, --help    Print this message
    -i, --inplace Modify file in situ
    -p, --product PRODUCT=VERSION   Expand PRODUCT to use VERSION
    -w, --warn    Warn about versions that don't start with v or V
\end{verbatim}

Modify a ups table file replacing setupRequired and setupOptional
lines which refer to the current version by the actual version number
of the currently setup product; e.g.
\begin{verbatim}
      setupRequired("-f ${EUPS_FLAVOR} astroda")
\end{verbatim}
becomes
\begin{verbatim}
      setupRequired("-f ${EUPS_FLAVOR} astroda v13_1")
\end{verbatim}
You can override the version with e.g. \code{-p astroda=rhl}; more
than one \code{-p} command is permitted.

If a directory is specified, the modified table file will be written
there, with the same name as the original; otherwise it's written to
standard out unless you specify \code{--inplace}, in which case the
substitution will be done in situ.
You may omit file.table, or specify it as "-", to read standard input;
this implies \code{--inplace}.

For example, the make target in a ups directory might contain the line:
\begin{verbatim}
      eups_expandtable -w iop.table $(IOP_DIR)/ups
\end{verbatim}				% $ for emacs

%------------------------------------------------------------------------------

\item \code{eups\_flavor}
\begin{verbatim}
Usage:
   eups_flavor
\end{verbatim}
  
Print your machine/operating system's flavor.  In simple cases, this'll
be the same as \code{uname -m}, but in reality it has to worry about things
like 32/64 bit libraries and os/x running on both PPC and X86 architectures.

%------------------------------------------------------------------------------

\item \code{eups\_pkg-config}
\begin{verbatim}
Usage:
   eups_pkg-config product [flags]
Flags:
(same as pkg-config)
\end{verbatim}

The same as the standard \code{pkg-config} command, except that it
searches \code{\$PRODUCT\_DIR/etc} for the \code{.pc} file.  It also
works around the problem that quoted variables \code{\$\$\{...\}}
in \code{.pc} files appear as \code{\%\{...\}} in \code{pkg-config} output.\footnote{
  Yes; I filed a Debian bug report (378570) and it's fixed in the next release, 0.21-1}
  
%------------------------------------------------------------------------------

  \item \code{eups\_undeclare}
\begin{verbatim}
Usage:
   eups_undeclare [options] product version
Options:
        -h, --help      Print this help message
        -c, --current   Make no version of product current
        -f, --flavor    Use this flavor (default: `eups\_flavor` or $EUPS_FLAVOR)
        -V, --version   Print eups version number and exit
        -v, --verbose   Be chattier (repeat for even more chat)
        -Z, --database  Use this products directory (default: $EUPS_PATH)
        -z, --select-db Select the product paths which contain this directory 
                        (default: all)
\end{verbatim}
  
Undeclares \code{version} of \code{product} from the database. Also
removes any declarations of this version from \code{current.chain}; if
you just want to stop any version from being declared current, use
\code{--current}. The flavor is usually determined from the value
of `eups\_flavor`, but can be set by the
environment variable \code{\$EUPS\_FLAVOR}; \code{-f} overrides
both of these.

The database used is the first element in the environment
variable \code{EUPS\_PATH}. That path list can also be specified or
overwritten with the \code{-Z} option. And if the \code{-z} option is
used, it selects the paths in the list which have a matching directory
name. (e.g. \code{-Z /home/proj1/eups:/home/proj2/eups -z proj2} would
yield \code{/home/proj2/eups}).

%------------------------------------------------------------------------------

\item \code{setup}
\begin{verbatim}
Usage:
   setup [options] [product [version]]
Options:
        -h, --help      Print this help message
        -c, --current   Show current version
        -d  --directory Print product directory to stderr (useful with -s)
        -D, --only-dependencies Only setup dependencies, not this product	
        -f, --flavor    Use this flavor (default: `eups\_flavor` or $EUPS_FLAVOR)
        -F, --force     Force requested behaviour, even if product's already setup
        -j, --just      Just setup product, no dependencies
        -l, --list      List available versions (-v => include root directories)
        -l, --list      List available versions (-v => include root directories)
        -m, --table     Print table file name to stderr (useful with -s)
        -M              Setup the dependent products in this table file
        -n, --noaction  Don't actually do anything
        -q, --quiet     Be extra quiet (the opposite of -v)
        -r, --root      Location of product being setup
        -s, --setup     Show which version is setup
        -V, --version   Print eups version number and exit
        -v, --verbose   Be chattier (repeat for even more chat)
        -Z, --database  Use this products directory (default: $EUPS_PATH)
        -z, --select-db Select the product paths which contain this directory 
                        (default: all)
\end{verbatim}				% $ for emacs

This is the workhorse routine. It sets up \code{version} of \code{product}.

\textbf{Important}: Since the commands to set environment variables differ across shells,
it is essential that \code{\$SHELL} reflects the current shell.

Options \code{--current} and \code{--setup} are only relevant with \code{--directory}
or \code{--list}.

(N.b. setup is really an alias or shell function that runs the command\hfil\break
\code{source `eups\_setup [options] "setup" product [version]`}\hfil\break
\code{eups\_setup} writes a shell script that is then sourced into the
current shell.
)

With the \code{--list} option, \code{setup} can be used to list the available
products; for example \code{setup --list --current} will list all products that
are declared current. Adding the \code{--verbose} option will also
list the database root and product root paths.  If you only want the product's
directory, you can use \code{--directory}.  This command is deprecated; use
\code{eups list} instead.

If you set verbose to three or more, the file that \code{setup} writes (and
which is sourced to modify your current shell's variables) is not deleted
after use, allowing you to peruse it at your leisure.

The \code{-D} option specifies that the product itself \textit{not} be
setup, but that it's dependencies should be processed as normal.

With \code{-M} you specify a table file for something that may not
even be declared to \eups{}; this is useful for setting up dependent
products during installation.  Implies \code{-D}, and you may not
specify a product name. \emph{N.b.} this is not the way to set up
a local product --- use \code{setup --root dir product} (e.g. setup -r . product).

If \eups{} detects an error, the file-to-source will be empty (i.e.
the setup will be aborted) unless you specify \code{--force}.

%------------------------------------------------------------------------------

\item \code{unsetup}
\begin{verbatim}
Usage:
   unsetup [options] product
Options:
(same as setup)
\end{verbatim}
  
All the notes under \code{setup} apply to
\code{unsetup}. Unsetting up a product relies on the environment
variable \code{\$SETUP\_<product>}, so it fails if the variable
isn't set (unless you use \code{-M}).

\end{itemize}

\subsection{Environment Variables}

Required variables -

\begin{itemize}
  \item \code{SHELL}
    This must be set to the shell that you're running. This is
    generally set correctly for you, unless you run a shell script, or
    change your shell.

  \item \code{EUPS\_DIR}
    Where \eups{} is installed.

  \item \code{EUPS\_PATH}
    The colon-separated path of root directories under which all products are installed.
    Each root directory has a UPS database in a top-level \code{ups\_db} directory.
    As of \code{v0\_7\_33}, when you source \code{setups.[c]sh}, any
    pre-existing value of \code{EUPS\_PATH} is preserved at the end of
    your new path.
\end{itemize}

Optional Variables -

\begin{itemize}
  \item \code{EUPS\_FLAVOR}
    Set to the default flavor (if not set \eups{} will use the value returned
    by \code{eups\_flavor}).

  \item \code{EUPS\_DEBUG}
    This sets the verbosity; equal to the difference between the number of \code{-v}s
    and \code{-q}s.

    If you are confused by some error, or simply nosy, try adding a \code{-v}.
\end{itemize}

\subsection{The Database}

\subsubsection{\eups{} Files}

This section briefly describes the structure of the UPS database. Each
EUPS root directory in \code{EUPS\_PATH} contains a database directory
\code{ups\_db}, with a subdirectory for each declared product.  Each
of these product directories contain a series of product definitions,
specified by three types of files:

\begin{itemize}
  \item current.chain

    There is only one (if any) of these per directory.  The
    current.chain file specifies the current version for a given
    flavor, and is what is used as the default if the version is not
    specified.

  \item Version files

    There is one of these for every declared version of the product,
    named \file{<version>.version}. The file specifies basic information
    about the version of the product, including where it is installed.

  \item Table files

    These specify the dependencies of the product. The default name
    for these is \file{<version>.table} although a specific name can be specified in the
    version file.

    Table files use a series of commands to specify the dependencies. These are
    discussed in the next subsection.

    NOTE: See Section 5 for a note on the search algorithm that \eups{} uses for 
    locating table files.
\end{itemize}

\subsubsection{\eups{} commands}

The following table commands are supported by \eups{}: (\code{<Name>} either specifies an
alias or an environment variable - clear from the context.)

\begin{itemize}
   \item \code{addAlias(<Name>,<Value>)}
     Defines a function or an alias.  Arguments should be written in
     sh format (i.e. \code{\$@} not \code{\textbackslash!*}); don't worry,
     the csh alias will be defined correctly.  E.g.
     \begin{verbatim}
     addAlias(foo, source `${PRODUCT_DIR}/bin/eups_setup setup $@`;);
     \end{verbatim}
    
   \item \code{envAppend(<Name>, <Value> [,<delimiter>])}
     Appends \code{<Value>} to \code{<Name>}. The default delimiter is~`:'.
     If \code{<Value>} starts or ends
     with \code{<Delimiter>, the final value of \code{<Name>} will
     have a delimiter pre- or -appended;  this is useful
     for variables such as \{MANPATH} which use such an empty
     element to mean, ``use the default path too''. E.g.
     \begin{verbatim}
     envAppend(MANPATH, :${PRODUCT_DIR}/man)
     \end{verbatim}		% $
     
   \item \code{envPrepend(<Name>,<Value> [,<delimiter>])}
     Similar to envAppend
     
   \item \code{envSet(<Name>, <Value>)}
     Set \code{<Name>} to \code{<Value>}
     
   \item \code{setupRequired(<Name> [ <Version>])}
     Setup \code{<Name>}.  If no \code{<Version>} is specified, the current
     version is used. Fails if unable to setup.

     \code{Version} may in fact be a logical expression, specifying acceptable
     versions. Permitted relational expressions are \code{>}, \code{>=}, \code{==},
     \code{<}, and \code{<=}. More than one expression may be joined using \code{||}
     (\code{\&\&} is not supported due to laziness).  For example,
\begin{verbatim}
    setupRequired(foo 1.2)
    setupRequired(foo == 1.2)
    setupRequired(foo >= 1.2)
    setupRequired(foo < 1.3)
    setupRequired(foo >= 1.2 || == rhl)
    setupRequired(foo >= 1.2 || rhl || svn)
\end{verbatim}
    The \code{==} is optional.  See the Sec. \ref{versionOrdering} for the definition
    of the ordering applied to version names.

    If more than one version matches the specified condition, priority is
    given to the version declared current;  if there is no current
    version, or it doesn't satisfy the condition, the highest valid version number
    is used.
     
   \item \code{setupOptional(<Name> [ <Version>]}
     Same as setupRequired except that it does not fail if unable to setup.
\end{itemize}

There are also \code{envRemove} and \code{envUnset()} commands, which
are the inverse of \code{env\{Ap,Pre\}pend} and \code{envSet()}; I have
never used either.     

\subsubsection{Version ordering}
\label{versionOrdering}

Version names are taken to be of the form \code{PrefixAAA.BBB.CCC-LLL.MMM.NNN+XXX.YYY.ZZZ}
where \code{Prefix} is optional, as are \code{-LLL.MMM.NNN} and \code{+XXX.YYY.ZZZ}.  Let's call
\code{PrefixAAA.BBB.CCC} the `primary' part, \code{LLL.MMM.NNN} the `secondary' part, and \code{XXX.YYY.ZZZ}
the `tertiary' part.
Each of the `dotted' parts may have any number of components. If you wish, you may use \code{\_}
instead of \code{.} as separators (this makes cvs happier).  Examples of valid
versions are:
\begin{verbatim}
  1.2.3
  v1.2.3.4
  a.b.c
  1.2.3-a.b
  1.2.3+a.b
  1.2.3-rc2+a.b
\end{verbatim}

The sorting rules are:
\begin{enumerate}
  \item If the version starts with non-digits (i.e. \code{Prefix} is provided),
    the two versions must have identical prefixes, or the first will sort to the
    left of the second (i.e. it can never satisfy \code{<}, \code{<=}, or \code{==}).

    If \code{Prefix} matches, it's ignored for the rest of the comparison.

  \item The primary part is then split on \code{.} (or \code{\_}), and
    each pair of components in the two names is compared numerically (if they look like
    integers) or lexicographically (otherwise). If they differ, the version name
    with the ``smaller'' component is taken to sort to the left, and the comparison
    stops.

  \item If one of the two version names is a subset of the other
    the longer version sorts to the right.  This only applies to the
    primary part; any secondary part is ignored in this comparison.

  \item If the two primary parts are identical, then the secondary part is
    examined.  Apart from the fact that no \code{Prefix} is allowed, the same
    rules are applied.  If only one version has a secondary part, it sorts
    to the \emph{left} -- so \code{1.2-rc2} sorts to the left of \code{1.2}.

  \item If the primary and secondary parts are identical, then the tertiary part is
    examined, applying the same rules as the secondary, except that if only one
    version has a tertiary part it sorts to the \emph{right}, so \code{1.2+hack}
    sorts to the right of \code{1.2}.
\end{enumerate}

What's the point of these complicated rules?  The primary sort should be
intuitive.  People often name \emph{pre-}release candidates things like
\code{1.2-rc2}, hence the rule for \code{1.2} being later than \code{1.2-rc2}.
After a version is released, you sometimes need a fixed version, so its
name should sort later --- hence \code{1.2+bugfix}.

Here are some examples:

\begin{tabular}{l|l|r|l}%
$v_1$ & $v_2$ & compar & notes \\
\hline
aa & aa & 0 & \\
aa.2 & aa.1 & +1 & Sort components numerically \\
aa.2.1 & aa.2 & +1 & \\
aa.2.1 & aa.2.2 & -1 & \\
aa.2.1 & aa.3 & -1 & \\
aa.2.b & aa.2.a & +1 & Sort components lexicographically \\
aa.2.b & aa.2.c & -1 & \\
v1\_0\_3 & a1.0.2 & -1 & Mismatching prefixes always sort to the left \\
v1\_0\_0 & 1.0.2 & -1 & Only $v_1$ has a prefix \\
1\_0\_0 & v1.0.2 & -1 & Only $v_2$ has a prefix\\
v1\_0\_2 & v1.0.0 & +1 & You can mix \code{.} and \code{\_} \\
v1.2.3 & v1.2.3-a & +1 & primary parts are identical, so secondary is examined \\
v1.2-0 & v1.2.3 & -1 & primary parts differ, so secondary parts are ignored \\
v1.2-4 & v1.2.3 & -1 & primary parts differ, so secondary parts are ignored \\
1-rc2+a & 1-rc2 & +1 & primary and secondary match; tertiary sorts to right \\
1-rc2+a & 1-rc2+b & -1 & sort is on tertiary \\
\end{tabular}

(Here compar is the value that C's \code{qsort} would use;  -1 if $v_1$ is less
than $v_2$; 0 if they're equal; +1 if $v_1 > v_2$).

\subsubsection{Obsolete table commands}

\begin{itemize}
   \item \code{pathAppend}, \code{pathPrepend}, \code{pathRemove}, \code{pathSet}
     Aliases for the \code{env} commands.
     
   \item \code{prodDir()}
     Sets \code{<PRODUCT>\_DIR} to the directory where the product is installed;
     this directive is ignored as \code{<PRODUCT>\_DIR} is automatically set for you.
     
   \item \code{setupEnv()}
     Sets \code{SETUP\_<PRODUCT>} so that product can be unsetup.
     this directive is ignored as \code{<PRODUCT>\_DIR} is automatically set for you.
\end{itemize}
        
\subsubsection{Variables}

The values to these UPS commands can be variables. All environment
variables can be used as \${<ENV\_VARIABLE>}. In addition, the following special
variables are defined;

\begin{itemize}
  \item \code{\${PRODUCTS}}
    The database
    
  \item \code{\${PRODUCT\_DIR}}
    Where the product is installed.
    
  \item \code{\${PRODUCT\_FLAVOR}}
    The product flavor.
    
  \item \code{\${PRODUCT\_NAME}}
    The product name
    
  \item \code{\${PRODUCT\_VERSION}}
    The product version
    
  \item \code{\${UPS\_DIR}}
    The ups directory of the product (distinct from the directory
    in \code{\$PRODUCTS} - this is often where the table file will be stored).
\end{itemize}

\subsection{\eups{} autoconf commands}
\label{autoconfReference}

\XXX{Finish me}

\begin{itemize}
  \item{\code{AC\_INIT(product, version, ...}}
    This is a standard autoconf line, but with an invalid version name (\code{X.Y}).

  \item{\code{AC\_DEFINE\_ROOT(version [, flavor])}}
    Define the \code{configure} options
    \begin{itemize}
      \item{\code{--with-eups=path}}
        Specify the value of \code{EUPS\_PATH} and the prefix
        (defaults: \code{\$EUPS\_PATH} if set, or \code{\$prefix/share}. The
	prefix is taken to be the first component of the prefix, unless
	\code{--with-eups-db} is specified.

	\item{\code{--with-eups-db=DB}}
	  Select which component of the path is the prefix (just like setup's \code{-z}).
	  For example, if \code{EUPS\_PATH} is
    \code{/u/dss/products:/u/act/products} then the default prefix is
    \code{/u/dss/products}, but with \code{\--with-eups-db=act} the
    prefix becomes \code{/u/act/products}.
    
	\item{\code{--with-flavor=XXX}}
        Set the value of \code{EUPS\_FLAVOR}
        (default: \code{\$EUPS\_FLAVOR}, or the value returned by \code{eups\_flavor}
	or, failing \textbf{that}, uname).
    \end{itemize}
\end{itemize}

The conventional files are:
\begin{itemize}
   \item{etc/builddefs}
     Supports building on this platform. E.g.
\begin{verbatim}
CC = cc -std=c99
CFLAGS = -g -Wall
RANLIB = ranlib
\end{verbatim}
  
   \item{etc/installdefs}
     Supports the \code{make install} and \code{make declare} targets.
  
   \item{etc/makedefs}
     Supports building and linking products (GSL in this case). After
     expansion, the file will look like:
\begin{verbatim}
GSL_CFLAGS = -I$(GSL_DIR)/include
GSL_LIBS = -L$(GSL_DIR)/lib -lgsl -lgslcblas -lm
\end{verbatim}
\end{itemize}
  
\section{Installing \eups{}}
  
  To install you need first to generate a Makefile:
\begin{verbatim}
./configure && make install
\end{verbatim}

You can say \code{make show} to show you where things are
going to be installed:
\begin{verbatim}
$ make show
You will be installing ups in $EUPS_DIR  = /usr/local/share/eups
Ups will look for products in $EUPS_PATH = /usr/local/share
Your EUPS database will be                 /usr/local/share/ups_db
\end{verbatim}				% $ for emacs
If you already have the environment variable \code{\$EUPS\_PATH} set,
then \code{EUPS\_PATH} will default to the old value.

You can control where files are put with the following configure options:
\begin{verbatim}
--prefix=PREFIX         install architecture-independent files in PREFIX
                        [default: /usr/local]
--with-eups=PATH        Use PATH as root for installed products
--with-eups-db=DB       Select component of path to use for EUPS_DIR;
                        "/eups" will be appended [default: first]
--with-eups_dir=DIR     Install eups into DIR/{bin,doc}
\end{verbatim}
The difference between \code{--prefix} and \code{--with-eups}
is that the former appends \code{/share} to the specified directory, to
be consistent with the standard default value, \code{/usr/local}.

If you don't explicitly choose a \code{EUPS\_DIR} with
\code{--with-eups\_dir} or \code{--with-eups-db} the value from the
environment will be adopted. If you don't have \code{EUPS\_DIR} set,
the first component of the \code{PATH} will be used, with \code{/eups}
appended.
  
As an alternative to
\begin{verbatim}
./configure --with-eups=/foo/bar/share
...
make install
\end{verbatim}
you can say
\begin{verbatim}
make install EUPS_PATH=/foo/bar/share
\end{verbatim}
\code{make install prefix=...} also works as an alternative to \code{--prefix=...}.
Note that \code{prefix} is ignored if you've set \code{EUPS\_PATH} either explicitly
or implicitly via an environment variable; \code{make show} is your friend.

\subsubsection{Working with multiple copies of \eups}

This may only be of interest to the authors.  You can declare \eups{} as a full-up
\eups{} product in its own right, and use \code{setup eups version} to switch
between them.  To make this easier, the main Makefile allows you to say,
\code{make declare} to declare your new version.

\subsection{Obsolete features}

\begin{itemize}
  \item The environment variable \code{\$EUPS\_PATH} used to be known
  as \code{\$PROD\_DIR\_PREFIX}. This is no longer supported.

  \item The \eups{} database used to be given by the environment variable \code{\$PRODUCTS}
    with a default value of \code{\$PROD\_DIR\_PREFIX/ups\_db}. This is no longer supported.
\end{itemize}

\section{Pacman}
\label{pacman}

\pacman{} is a package used by the HEP community (e.g. Atlas) to distribute
software.  It doesn't solve the same problem as \eups{} (supporting 
multiple simultaneous versions of the same package), but it does nicely
support building packages from source.  The home page is \code{http://physics.bu.edu/pacman/}.

An example \pacman{} script is
\begin{verbatim}
#
# Sample product installation using pacman
#
# author: RHL
# data:   2006/12/04
#
packageName('hello')
url('Foo', 'file:///dev/null')
#
# N.b. version is also encoded in directory name below
#
version('v1_0_0')
#
# Package requirements
#
platformGE("unix")
which("gcc"); which("make")
#
# Prepare to install
#
downloadUntar('/Users/rhl/LSST/Pacman-test/packages/hello-v1_0_0.tar.gz', 'HELLO_DIR')
cd('$HELLO_DIR')
cd('v1_0_0')
shell("make")
shell("make install")
\end{verbatim}				% $ for emacs

\subsection{Using \pacman{} with \eups{}}

To use \pacman{}, simply specify a \pacman{} cache when running \code{eups distrib --create}:
\begin{verbatim}
eups distrib -z lsst --pacman http://lsst.org/cache --create hello
\end{verbatim}

The \code{eups distrib --install} command is unchanged:
\begin{verbatim}
eups distrib --install -r /u/lsst/products/packages/Darwin -z act hello v1_0_0
\end{verbatim}

\end{document}
